# coding: utf-8

"""
    Sonic NMS

    Network management Open APIs for Broadcom's Sonic.  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: mohammed.faraaz@broadcom.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class OpenconfigAclApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_acl(self, **kwargs):  # noqa: E501
        """delete_acl  # noqa: E501

        OperationId: delete_acl Top level enclosing container for ACL model config and operational state data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Acl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_acl_with_http_info(self, **kwargs):  # noqa: E501
        """delete_acl  # noqa: E501

        OperationId: delete_acl Top level enclosing container for ACL model config and operational state data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Acl
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Acl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_acl_sets(self, **kwargs):  # noqa: E501
        """delete_acl_acl_sets  # noqa: E501

        OperationId: delete_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_acl_sets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AclAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_acl_sets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_acl_sets_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_acl_acl_sets_with_http_info(self, **kwargs):  # noqa: E501
        """delete_acl_acl_sets  # noqa: E501

        OperationId: delete_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_acl_sets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AclAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclAclSets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_acl_sets_acl_set(self, name, type, **kwargs):  # noqa: E501
        """delete_acl_acl_sets_acl_set  # noqa: E501

        OperationId: delete_acl_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_acl_sets_acl_set(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: AclAclSetsAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_acl_sets_acl_set_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_acl_sets_acl_set_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def delete_acl_acl_sets_acl_set_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """delete_acl_acl_sets_acl_set  # noqa: E501

        OperationId: delete_acl_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_acl_sets_acl_set_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: AclAclSetsAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_acl_sets_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_acl_sets_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclAclSetsAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_entry_actions(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_actions  # noqa: E501

        OperationId: delete_acl_entry_actions Enclosing container for list of ACL actions associated with an entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_actions(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryActions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_entry_actions_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_entry_actions_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_entry_actions_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_actions  # noqa: E501

        OperationId: delete_acl_entry_actions Enclosing container for list of ACL actions associated with an entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_actions_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryActions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_entry_actions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_entry_actions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclEntryActions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_entry_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_config  # noqa: E501

        OperationId: delete_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_entry_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_entry_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_entry_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_config  # noqa: E501

        OperationId: delete_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_entry_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_entry_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclEntryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_entry_config_description(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_config_description  # noqa: E501

        OperationId: delete_acl_entry_config_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_config_description(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryConfigDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_entry_config_description_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_entry_config_description_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_entry_config_description_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_config_description  # noqa: E501

        OperationId: delete_acl_entry_config_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_config_description_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryConfigDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_entry_config_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_entry_config_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config/description', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclEntryConfigDescription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_entry_input_interface(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_input_interface  # noqa: E501

        OperationId: delete_acl_entry_input_interface Input interface container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_input_interface(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryInputInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_entry_input_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_entry_input_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_entry_input_interface_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_input_interface  # noqa: E501

        OperationId: delete_acl_entry_input_interface Input interface container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_input_interface_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryInputInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_entry_input_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_entry_input_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclEntryInputInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_entry_ipv4(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_ipv4  # noqa: E501

        OperationId: delete_acl_entry_ipv4 Top level container for IPv4 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_ipv4(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryIpv4
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_entry_ipv4_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_entry_ipv4_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_entry_ipv4_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_ipv4  # noqa: E501

        OperationId: delete_acl_entry_ipv4 Top level container for IPv4 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_ipv4_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryIpv4
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_entry_ipv4" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_entry_ipv4`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclEntryIpv4',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_entry_ipv6(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_ipv6  # noqa: E501

        OperationId: delete_acl_entry_ipv6 Top-level container for IPv6 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_ipv6(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryIpv6
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_entry_ipv6_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_entry_ipv6_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_entry_ipv6_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_ipv6  # noqa: E501

        OperationId: delete_acl_entry_ipv6 Top-level container for IPv6 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_ipv6_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryIpv6
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_entry_ipv6" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_entry_ipv6`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclEntryIpv6',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_entry_l2(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_l2  # noqa: E501

        OperationId: delete_acl_entry_l2 Ethernet header fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_l2(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryL2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_entry_l2_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_entry_l2_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_entry_l2_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_l2  # noqa: E501

        OperationId: delete_acl_entry_l2 Ethernet header fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_l2_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryL2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_entry_l2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_entry_l2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclEntryL2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_entry_transport(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_transport  # noqa: E501

        OperationId: delete_acl_entry_transport Transport fields container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_transport(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryTransport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_entry_transport_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_entry_transport_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_entry_transport_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_entry_transport  # noqa: E501

        OperationId: delete_acl_entry_transport Transport fields container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_entry_transport_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclEntryTransport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_entry_transport" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_entry_transport`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclEntryTransport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_interfaces(self, **kwargs):  # noqa: E501
        """delete_acl_interfaces  # noqa: E501

        OperationId: delete_acl_interfaces Enclosing container for the list of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_interfaces(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AclInterfaces
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_interfaces_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_interfaces_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_acl_interfaces_with_http_info(self, **kwargs):  # noqa: E501
        """delete_acl_interfaces  # noqa: E501

        OperationId: delete_acl_interfaces Enclosing container for the list of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_interfaces_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AclInterfaces
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_interfaces" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclInterfaces',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_interfaces_interface(self, id, **kwargs):  # noqa: E501
        """delete_acl_interfaces_interface  # noqa: E501

        OperationId: delete_acl_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_interfaces_interface(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: AclInterfacesInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_interfaces_interface_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_interfaces_interface_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_acl_interfaces_interface_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_acl_interfaces_interface  # noqa: E501

        OperationId: delete_acl_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_interfaces_interface_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: AclInterfacesInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_acl_interfaces_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclInterfacesInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_set_acl_entries(self, name, type, **kwargs):  # noqa: E501
        """delete_acl_set_acl_entries  # noqa: E501

        OperationId: delete_acl_set_acl_entries Access list entries container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_set_acl_entries(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: AclSetAclEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_set_acl_entries_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_set_acl_entries_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def delete_acl_set_acl_entries_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """delete_acl_set_acl_entries  # noqa: E501

        OperationId: delete_acl_set_acl_entries Access list entries container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_set_acl_entries_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: AclSetAclEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_set_acl_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_set_acl_entries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclSetAclEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_set_acl_entries_acl_entry(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: delete_acl_set_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_set_acl_entries_acl_entry(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_acl_set_acl_entries_acl_entry_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: delete_acl_set_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: AclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_set_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_acl_set_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclSetAclEntriesAclEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_acl_set_config(self, name, type, **kwargs):  # noqa: E501
        """delete_acl_set_config  # noqa: E501

        OperationId: delete_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_set_config(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: AclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_acl_set_config_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_acl_set_config_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def delete_acl_set_config_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """delete_acl_set_config  # noqa: E501

        OperationId: delete_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_acl_set_config_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: AclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AclSetConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_actions_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_actions_config  # noqa: E501

        OperationId: delete_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_actions_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ActionsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_actions_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_actions_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_actions_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_actions_config  # noqa: E501

        OperationId: delete_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_actions_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ActionsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_actions_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_actions_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_actions_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_actions_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActionsConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_description(self, name, type, **kwargs):  # noqa: E501
        """delete_config_description  # noqa: E501

        OperationId: delete_config_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_description(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: ConfigDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_description_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_description_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def delete_config_description_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """delete_config_description  # noqa: E501

        OperationId: delete_config_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_description_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: ConfigDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/description', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigDescription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_destination_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_address  # noqa: E501

        OperationId: delete_config_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_destination_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_address  # noqa: E501

        OperationId: delete_config_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/destination-address', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigDestinationAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_destination_flow_label(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_flow_label  # noqa: E501

        OperationId: delete_config_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_flow_label(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_destination_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_destination_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_destination_flow_label_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_flow_label  # noqa: E501

        OperationId: delete_config_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_flow_label_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_destination_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_destination_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/destination-flow-label', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigDestinationFlowLabel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_destination_mac(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_mac  # noqa: E501

        OperationId: delete_config_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_mac(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationMac
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_destination_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_destination_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_destination_mac_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_mac  # noqa: E501

        OperationId: delete_config_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_mac_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationMac
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_destination_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_destination_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/destination-mac', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigDestinationMac',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_destination_mac_mask(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_mac_mask  # noqa: E501

        OperationId: delete_config_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_mac_mask(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_destination_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_destination_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_destination_mac_mask_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_mac_mask  # noqa: E501

        OperationId: delete_config_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_mac_mask_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_destination_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_destination_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/destination-mac-mask', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigDestinationMacMask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_destination_port(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_port  # noqa: E501

        OperationId: delete_config_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_port(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_destination_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_destination_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_destination_port_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_destination_port  # noqa: E501

        OperationId: delete_config_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_destination_port_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDestinationPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_destination_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_destination_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_destination_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_destination_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/destination-port', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigDestinationPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_dscp(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_dscp  # noqa: E501

        OperationId: delete_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_dscp(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_dscp_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_dscp  # noqa: E501

        OperationId: delete_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_dscp_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/dscp', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigDscp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_ethertype(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_ethertype  # noqa: E501

        OperationId: delete_config_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_ethertype(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigEthertype
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_ethertype_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_ethertype_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_ethertype_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_ethertype  # noqa: E501

        OperationId: delete_config_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_ethertype_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigEthertype
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_ethertype" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_ethertype`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_ethertype`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_ethertype`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/ethertype', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigEthertype',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_forwarding_action(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_forwarding_action  # noqa: E501

        OperationId: delete_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_forwarding_action(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigForwardingAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_forwarding_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_forwarding_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_forwarding_action_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_forwarding_action  # noqa: E501

        OperationId: delete_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_forwarding_action_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigForwardingAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_forwarding_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_forwarding_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config/forwarding-action', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigForwardingAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_hop_limit(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_hop_limit  # noqa: E501

        OperationId: delete_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_hop_limit(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_hop_limit_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_hop_limit  # noqa: E501

        OperationId: delete_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_hop_limit_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/hop-limit', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigHopLimit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_id(self, id, **kwargs):  # noqa: E501
        """delete_config_id  # noqa: E501

        OperationId: delete_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: ConfigId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_config_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_config_id  # noqa: E501

        OperationId: delete_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: ConfigId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_config_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config/id', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_interface(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_interface  # noqa: E501

        OperationId: delete_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_interface(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_interface_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_interface  # noqa: E501

        OperationId: delete_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_interface_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config/interface', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_log_action(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_log_action  # noqa: E501

        OperationId: delete_config_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_log_action(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigLogAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_log_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_log_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_log_action_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_log_action  # noqa: E501

        OperationId: delete_config_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_log_action_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigLogAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_log_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_log_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_log_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_log_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config/log-action', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigLogAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_name(self, name, type, **kwargs):  # noqa: E501
        """delete_config_name  # noqa: E501

        OperationId: delete_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_name(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: ConfigName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_name_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_name_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def delete_config_name_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """delete_config_name  # noqa: E501

        OperationId: delete_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_name_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: ConfigName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/name', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_protocol(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_protocol  # noqa: E501

        OperationId: delete_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_protocol(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_protocol_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_protocol  # noqa: E501

        OperationId: delete_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_protocol_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/protocol', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigProtocol',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_sequence_id(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_sequence_id  # noqa: E501

        OperationId: delete_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_sequence_id(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_sequence_id_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_sequence_id_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_sequence_id_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_sequence_id  # noqa: E501

        OperationId: delete_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_sequence_id_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_sequence_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_sequence_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config/sequence-id', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigSequenceId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_set_name(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_config_set_name  # noqa: E501

        OperationId: delete_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_set_name(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: ConfigSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def delete_config_set_name_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_config_set_name  # noqa: E501

        OperationId: delete_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_set_name_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: ConfigSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `delete_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config/set-name', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigSetName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_source_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_address  # noqa: E501

        OperationId: delete_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_source_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_address  # noqa: E501

        OperationId: delete_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/source-address', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigSourceAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_source_flow_label(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_flow_label  # noqa: E501

        OperationId: delete_config_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_flow_label(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourceFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_source_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_source_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_source_flow_label_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_flow_label  # noqa: E501

        OperationId: delete_config_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_flow_label_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourceFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_source_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_source_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/source-flow-label', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigSourceFlowLabel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_source_mac(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_mac  # noqa: E501

        OperationId: delete_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_mac(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourceMac
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_source_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_source_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_source_mac_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_mac  # noqa: E501

        OperationId: delete_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_mac_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourceMac
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_source_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_source_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_source_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_source_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/source-mac', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigSourceMac',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_source_mac_mask(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_mac_mask  # noqa: E501

        OperationId: delete_config_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_mac_mask(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourceMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_source_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_source_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_source_mac_mask_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_mac_mask  # noqa: E501

        OperationId: delete_config_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_mac_mask_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourceMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_source_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_source_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/source-mac-mask', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigSourceMacMask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_source_port(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_port  # noqa: E501

        OperationId: delete_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_port(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourcePort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_source_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_source_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_source_port_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_source_port  # noqa: E501

        OperationId: delete_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_port_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSourcePort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_source_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_source_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_source_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_source_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/source-port', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigSourcePort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_subinterface(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_subinterface  # noqa: E501

        OperationId: delete_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_subinterface(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_subinterface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_subinterface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_subinterface_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_subinterface  # noqa: E501

        OperationId: delete_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_subinterface_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_subinterface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_subinterface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config/subinterface', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigSubinterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_tcp_flags(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_tcp_flags  # noqa: E501

        OperationId: delete_config_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_tcp_flags(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigTcpFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_tcp_flags_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_tcp_flags_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_config_tcp_flags_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_config_tcp_flags  # noqa: E501

        OperationId: delete_config_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_tcp_flags_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: ConfigTcpFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_tcp_flags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_config_tcp_flags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/tcp-flags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigTcpFlags',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_type(self, name, type, **kwargs):  # noqa: E501
        """delete_config_type  # noqa: E501

        OperationId: delete_config_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_type(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: ConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_type_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_type_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def delete_config_type_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """delete_config_type  # noqa: E501

        OperationId: delete_config_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_type_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: ConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/type', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_egress_acl_set_config(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_egress_acl_set_config  # noqa: E501

        OperationId: delete_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_egress_acl_set_config(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: EgressAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_egress_acl_set_config_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_egress_acl_set_config_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def delete_egress_acl_set_config_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_egress_acl_set_config  # noqa: E501

        OperationId: delete_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_egress_acl_set_config_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: EgressAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_egress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `delete_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_egress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EgressAclSetConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_egress_acl_set_config_set_name(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_egress_acl_set_config_set_name  # noqa: E501

        OperationId: delete_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_egress_acl_set_config_set_name(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: EgressAclSetConfigSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_egress_acl_set_config_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_egress_acl_set_config_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def delete_egress_acl_set_config_set_name_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_egress_acl_set_config_set_name  # noqa: E501

        OperationId: delete_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_egress_acl_set_config_set_name_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: EgressAclSetConfigSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_egress_acl_set_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `delete_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_egress_acl_set_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config/set-name', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EgressAclSetConfigSetName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_egress_acl_set_config_type(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_egress_acl_set_config_type  # noqa: E501

        OperationId: delete_egress_acl_set_config_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_egress_acl_set_config_type(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: EgressAclSetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_egress_acl_set_config_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_egress_acl_set_config_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def delete_egress_acl_set_config_type_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_egress_acl_set_config_type  # noqa: E501

        OperationId: delete_egress_acl_set_config_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_egress_acl_set_config_type_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: EgressAclSetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_egress_acl_set_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `delete_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_egress_acl_set_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config/type', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EgressAclSetConfigType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ingress_acl_set_config(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_ingress_acl_set_config  # noqa: E501

        OperationId: delete_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ingress_acl_set_config(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: IngressAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ingress_acl_set_config_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ingress_acl_set_config_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def delete_ingress_acl_set_config_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_ingress_acl_set_config  # noqa: E501

        OperationId: delete_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ingress_acl_set_config_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: IngressAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ingress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `delete_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ingress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IngressAclSetConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ingress_acl_set_config_type(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_ingress_acl_set_config_type  # noqa: E501

        OperationId: delete_ingress_acl_set_config_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ingress_acl_set_config_type(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: IngressAclSetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ingress_acl_set_config_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ingress_acl_set_config_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def delete_ingress_acl_set_config_type_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_ingress_acl_set_config_type  # noqa: E501

        OperationId: delete_ingress_acl_set_config_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ingress_acl_set_config_type_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: IngressAclSetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ingress_acl_set_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `delete_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ingress_acl_set_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config/type', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IngressAclSetConfigType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_input_interface_interface_ref(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_input_interface_interface_ref  # noqa: E501

        OperationId: delete_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_input_interface_interface_ref(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: InputInterfaceInterfaceRef
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_input_interface_interface_ref_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_input_interface_interface_ref_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_input_interface_interface_ref_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_input_interface_interface_ref  # noqa: E501

        OperationId: delete_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_input_interface_interface_ref_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: InputInterfaceInterfaceRef
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_input_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_input_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InputInterfaceInterfaceRef',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_config(self, id, **kwargs):  # noqa: E501
        """delete_interface_config  # noqa: E501

        OperationId: delete_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_config(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_config_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_config_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_interface_config_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_interface_config  # noqa: E501

        OperationId: delete_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_config_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_egress_acl_sets(self, id, **kwargs):  # noqa: E501
        """delete_interface_egress_acl_sets  # noqa: E501

        OperationId: delete_interface_egress_acl_sets Enclosing container the list of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_egress_acl_sets(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceEgressAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_egress_acl_sets_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_egress_acl_sets_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_interface_egress_acl_sets_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_interface_egress_acl_sets  # noqa: E501

        OperationId: delete_interface_egress_acl_sets Enclosing container the list of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_egress_acl_sets_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceEgressAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_egress_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_egress_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceEgressAclSets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_egress_acl_sets_egress_acl_set(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_interface_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: delete_interface_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_egress_acl_sets_egress_acl_set(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: InterfaceEgressAclSetsEgressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def delete_interface_egress_acl_sets_egress_acl_set_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_interface_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: delete_interface_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: InterfaceEgressAclSetsEgressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `delete_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceEgressAclSetsEgressAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_ingress_acl_sets(self, id, **kwargs):  # noqa: E501
        """delete_interface_ingress_acl_sets  # noqa: E501

        OperationId: delete_interface_ingress_acl_sets Enclosing container the list of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ingress_acl_sets(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceIngressAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_ingress_acl_sets_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_ingress_acl_sets_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_interface_ingress_acl_sets_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_interface_ingress_acl_sets  # noqa: E501

        OperationId: delete_interface_ingress_acl_sets Enclosing container the list of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ingress_acl_sets_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceIngressAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_ingress_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_ingress_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceIngressAclSets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_ingress_acl_sets_ingress_acl_set(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_interface_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: delete_interface_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ingress_acl_sets_ingress_acl_set(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: InterfaceIngressAclSetsIngressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def delete_interface_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """delete_interface_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: delete_interface_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: InterfaceIngressAclSetsIngressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `delete_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceIngressAclSetsIngressAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_interface_ref(self, id, **kwargs):  # noqa: E501
        """delete_interface_interface_ref  # noqa: E501

        OperationId: delete_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_interface_ref(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceInterfaceRef
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_interface_ref_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_interface_ref_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_interface_interface_ref_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_interface_interface_ref  # noqa: E501

        OperationId: delete_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_interface_ref_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceInterfaceRef
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceInterfaceRef',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_interface_ref_config(self, id, **kwargs):  # noqa: E501
        """delete_interface_interface_ref_config  # noqa: E501

        OperationId: delete_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_interface_ref_config(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceInterfaceRefConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_interface_ref_config_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_interface_ref_config_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_interface_interface_ref_config_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_interface_interface_ref_config  # noqa: E501

        OperationId: delete_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_interface_ref_config_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceInterfaceRefConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceInterfaceRefConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_ref_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_interface_ref_config  # noqa: E501

        OperationId: delete_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ref_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: InterfaceRefConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_ref_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_ref_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_interface_ref_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_interface_ref_config  # noqa: E501

        OperationId: delete_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ref_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: InterfaceRefConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceRefConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_ref_config_interface(self, id, **kwargs):  # noqa: E501
        """delete_interface_ref_config_interface  # noqa: E501

        OperationId: delete_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ref_config_interface(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceRefConfigInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_ref_config_interface_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_ref_config_interface_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_interface_ref_config_interface_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_interface_ref_config_interface  # noqa: E501

        OperationId: delete_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ref_config_interface_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceRefConfigInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_ref_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_ref_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config/interface', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceRefConfigInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_interface_ref_config_subinterface(self, id, **kwargs):  # noqa: E501
        """delete_interface_ref_config_subinterface  # noqa: E501

        OperationId: delete_interface_ref_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ref_config_subinterface(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceRefConfigSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_interface_ref_config_subinterface_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_interface_ref_config_subinterface_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_interface_ref_config_subinterface_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_interface_ref_config_subinterface  # noqa: E501

        OperationId: delete_interface_ref_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_interface_ref_config_subinterface_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: InterfaceRefConfigSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_interface_ref_config_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_interface_ref_config_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config/subinterface', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceRefConfigSubinterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ipv4_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv4_config  # noqa: E501

        OperationId: delete_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv4_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv4Config
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ipv4_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ipv4_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_ipv4_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv4_config  # noqa: E501

        OperationId: delete_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv4_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv4Config
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ipv4_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_ipv4_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ipv4_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_ipv4_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ipv4Config',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ipv6_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config  # noqa: E501

        OperationId: delete_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6Config
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ipv6_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ipv6_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_ipv6_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config  # noqa: E501

        OperationId: delete_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6Config
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ipv6_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_ipv6_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ipv6_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_ipv6_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ipv6Config',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ipv6_config_destination_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_destination_address  # noqa: E501

        OperationId: delete_ipv6_config_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_destination_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ipv6_config_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ipv6_config_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_ipv6_config_destination_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_destination_address  # noqa: E501

        OperationId: delete_ipv6_config_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_destination_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ipv6_config_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_ipv6_config_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/destination-address', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ipv6ConfigDestinationAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ipv6_config_dscp(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_dscp  # noqa: E501

        OperationId: delete_ipv6_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_dscp(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ipv6_config_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ipv6_config_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_ipv6_config_dscp_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_dscp  # noqa: E501

        OperationId: delete_ipv6_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_dscp_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ipv6_config_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_ipv6_config_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/dscp', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ipv6ConfigDscp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ipv6_config_hop_limit(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_hop_limit  # noqa: E501

        OperationId: delete_ipv6_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_hop_limit(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_ipv6_config_hop_limit_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_hop_limit  # noqa: E501

        OperationId: delete_ipv6_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ipv6_config_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_ipv6_config_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/hop-limit', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ipv6ConfigHopLimit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ipv6_config_protocol(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_protocol  # noqa: E501

        OperationId: delete_ipv6_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_protocol(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ipv6_config_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ipv6_config_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_ipv6_config_protocol_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_protocol  # noqa: E501

        OperationId: delete_ipv6_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_protocol_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ipv6_config_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_ipv6_config_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/protocol', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ipv6ConfigProtocol',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ipv6_config_source_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_source_address  # noqa: E501

        OperationId: delete_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_source_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ipv6_config_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ipv6_config_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_ipv6_config_source_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_ipv6_config_source_address  # noqa: E501

        OperationId: delete_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ipv6_config_source_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: Ipv6ConfigSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ipv6_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_ipv6_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/source-address', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ipv6ConfigSourceAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_l2_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_l2_config  # noqa: E501

        OperationId: delete_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_l2_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: L2Config
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_l2_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_l2_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_l2_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_l2_config  # noqa: E501

        OperationId: delete_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_l2_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: L2Config
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_l2_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_l2_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_l2_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_l2_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='L2Config',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_list_base_acl_entries_acl_entry(self, name, type, **kwargs):  # noqa: E501
        """delete_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: delete_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_acl_entries_acl_entry(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: ListBaseAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_list_base_acl_entries_acl_entry_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_list_base_acl_entries_acl_entry_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def delete_list_base_acl_entries_acl_entry_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """delete_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: delete_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_acl_entries_acl_entry_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: ListBaseAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_list_base_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_list_base_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_list_base_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListBaseAclEntriesAclEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_list_base_acl_sets_acl_set(self, **kwargs):  # noqa: E501
        """delete_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: delete_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_acl_sets_acl_set(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListBaseAclSetsAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_list_base_acl_sets_acl_set_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_list_base_acl_sets_acl_set_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_list_base_acl_sets_acl_set_with_http_info(self, **kwargs):  # noqa: E501
        """delete_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: delete_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_acl_sets_acl_set_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListBaseAclSetsAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_list_base_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListBaseAclSetsAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_list_base_egress_acl_sets_egress_acl_set(self, id, **kwargs):  # noqa: E501
        """delete_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: delete_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_egress_acl_sets_egress_acl_set(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: ListBaseEgressAclSetsEgressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_list_base_egress_acl_sets_egress_acl_set_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: delete_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: ListBaseEgressAclSetsEgressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_list_base_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_list_base_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListBaseEgressAclSetsEgressAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_list_base_ingress_acl_sets_ingress_acl_set(self, id, **kwargs):  # noqa: E501
        """delete_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: delete_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_ingress_acl_sets_ingress_acl_set(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: ListBaseIngressAclSetsIngressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: delete_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: ListBaseIngressAclSetsIngressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_list_base_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_list_base_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListBaseIngressAclSetsIngressAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_list_base_interfaces_interface(self, **kwargs):  # noqa: E501
        """delete_list_base_interfaces_interface  # noqa: E501

        OperationId: delete_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_interfaces_interface(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListBaseInterfacesInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_list_base_interfaces_interface_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_list_base_interfaces_interface_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_list_base_interfaces_interface_with_http_info(self, **kwargs):  # noqa: E501
        """delete_list_base_interfaces_interface  # noqa: E501

        OperationId: delete_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_base_interfaces_interface_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ListBaseInterfacesInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_list_base_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListBaseInterfacesInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_transport_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_transport_config  # noqa: E501

        OperationId: delete_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transport_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: TransportConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_transport_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_transport_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def delete_transport_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """delete_transport_config  # noqa: E501

        OperationId: delete_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transport_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: TransportConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_transport_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_transport_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `delete_transport_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `delete_transport_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl(self, **kwargs):  # noqa: E501
        """get_acl  # noqa: E501

        OperationId: get_acl Top level enclosing container for ACL model config and operational state data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetAcl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_acl_with_http_info(self, **kwargs):  # noqa: E501
        """get_acl  # noqa: E501

        OperationId: get_acl Top level enclosing container for ACL model config and operational state data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetAcl
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAcl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_acl_sets(self, **kwargs):  # noqa: E501
        """get_acl_acl_sets  # noqa: E501

        OperationId: get_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_acl_sets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetAclAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_acl_sets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_acl_sets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_acl_acl_sets_with_http_info(self, **kwargs):  # noqa: E501
        """get_acl_acl_sets  # noqa: E501

        OperationId: get_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_acl_sets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetAclAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclAclSets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_acl_sets_acl_set(self, name, type, **kwargs):  # noqa: E501
        """get_acl_acl_sets_acl_set  # noqa: E501

        OperationId: get_acl_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_acl_sets_acl_set(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetAclAclSetsAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_acl_sets_acl_set_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_acl_sets_acl_set_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_acl_acl_sets_acl_set_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_acl_acl_sets_acl_set  # noqa: E501

        OperationId: get_acl_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_acl_sets_acl_set_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetAclAclSetsAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_acl_sets_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_acl_sets_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclAclSetsAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entries_acl_entry_state(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entries_acl_entry_state  # noqa: E501

        OperationId: get_acl_entries_acl_entry_state Operational state data for per-interface ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entries_acl_entry_state(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntriesAclEntryState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entries_acl_entry_state_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entries_acl_entry_state_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entries_acl_entry_state_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entries_acl_entry_state  # noqa: E501

        OperationId: get_acl_entries_acl_entry_state Operational state data for per-interface ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entries_acl_entry_state_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntriesAclEntryState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entries_acl_entry_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_acl_entries_acl_entry_state`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_acl_entries_acl_entry_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entries_acl_entry_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entries_acl_entry_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntriesAclEntryState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entries_acl_entry_state_matched_octets(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entries_acl_entry_state_matched_octets  # noqa: E501

        OperationId: get_acl_entries_acl_entry_state_matched_octets Count of the number of octets (bytes) matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entries_acl_entry_state_matched_octets(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntriesAclEntryStateMatchedOctets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entries_acl_entry_state_matched_octets_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entries_acl_entry_state_matched_octets_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entries_acl_entry_state_matched_octets_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entries_acl_entry_state_matched_octets  # noqa: E501

        OperationId: get_acl_entries_acl_entry_state_matched_octets Count of the number of octets (bytes) matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entries_acl_entry_state_matched_octets_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntriesAclEntryStateMatchedOctets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entries_acl_entry_state_matched_octets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_acl_entries_acl_entry_state_matched_octets`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_acl_entries_acl_entry_state_matched_octets`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entries_acl_entry_state_matched_octets`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entries_acl_entry_state_matched_octets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}/state/matched-octets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntriesAclEntryStateMatchedOctets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entries_acl_entry_state_matched_packets(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entries_acl_entry_state_matched_packets  # noqa: E501

        OperationId: get_acl_entries_acl_entry_state_matched_packets Count of the number of packets matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entries_acl_entry_state_matched_packets(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntriesAclEntryStateMatchedPackets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entries_acl_entry_state_matched_packets_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entries_acl_entry_state_matched_packets_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entries_acl_entry_state_matched_packets_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entries_acl_entry_state_matched_packets  # noqa: E501

        OperationId: get_acl_entries_acl_entry_state_matched_packets Count of the number of packets matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entries_acl_entry_state_matched_packets_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntriesAclEntryStateMatchedPackets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entries_acl_entry_state_matched_packets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_acl_entries_acl_entry_state_matched_packets`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_acl_entries_acl_entry_state_matched_packets`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entries_acl_entry_state_matched_packets`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entries_acl_entry_state_matched_packets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}/state/matched-packets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntriesAclEntryStateMatchedPackets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entries_acl_entry_state_sequence_id(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entries_acl_entry_state_sequence_id  # noqa: E501

        OperationId: get_acl_entries_acl_entry_state_sequence_id Reference to an entry in the ACL set applied to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entries_acl_entry_state_sequence_id(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntriesAclEntryStateSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entries_acl_entry_state_sequence_id_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entries_acl_entry_state_sequence_id_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entries_acl_entry_state_sequence_id_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entries_acl_entry_state_sequence_id  # noqa: E501

        OperationId: get_acl_entries_acl_entry_state_sequence_id Reference to an entry in the ACL set applied to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entries_acl_entry_state_sequence_id_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntriesAclEntryStateSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entries_acl_entry_state_sequence_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_acl_entries_acl_entry_state_sequence_id`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_acl_entries_acl_entry_state_sequence_id`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entries_acl_entry_state_sequence_id`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entries_acl_entry_state_sequence_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}/state/sequence-id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntriesAclEntryStateSequenceId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_actions(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_actions  # noqa: E501

        OperationId: get_acl_entry_actions Enclosing container for list of ACL actions associated with an entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_actions(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryActions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_actions_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_actions_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_actions_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_actions  # noqa: E501

        OperationId: get_acl_entry_actions Enclosing container for list of ACL actions associated with an entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_actions_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryActions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_actions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_actions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryActions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_config  # noqa: E501

        OperationId: get_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_config  # noqa: E501

        OperationId: get_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_config_description(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_config_description  # noqa: E501

        OperationId: get_acl_entry_config_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_config_description(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryConfigDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_config_description_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_config_description_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_config_description_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_config_description  # noqa: E501

        OperationId: get_acl_entry_config_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_config_description_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryConfigDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_config_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_config_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config/description', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryConfigDescription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_input_interface(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_input_interface  # noqa: E501

        OperationId: get_acl_entry_input_interface Input interface container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_input_interface(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryInputInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_input_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_input_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_input_interface_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_input_interface  # noqa: E501

        OperationId: get_acl_entry_input_interface Input interface container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_input_interface_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryInputInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_input_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_input_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryInputInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_ipv4(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_ipv4  # noqa: E501

        OperationId: get_acl_entry_ipv4 Top level container for IPv4 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_ipv4(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryIpv4
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_ipv4_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_ipv4_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_ipv4_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_ipv4  # noqa: E501

        OperationId: get_acl_entry_ipv4 Top level container for IPv4 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_ipv4_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryIpv4
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_ipv4" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_ipv4`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryIpv4',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_ipv6(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_ipv6  # noqa: E501

        OperationId: get_acl_entry_ipv6 Top-level container for IPv6 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_ipv6(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryIpv6
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_ipv6_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_ipv6_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_ipv6_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_ipv6  # noqa: E501

        OperationId: get_acl_entry_ipv6 Top-level container for IPv6 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_ipv6_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryIpv6
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_ipv6" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_ipv6`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryIpv6',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_l2(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_l2  # noqa: E501

        OperationId: get_acl_entry_l2 Ethernet header fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_l2(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryL2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_l2_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_l2_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_l2_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_l2  # noqa: E501

        OperationId: get_acl_entry_l2 Ethernet header fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_l2_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryL2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_l2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_l2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryL2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_state(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state  # noqa: E501

        OperationId: get_acl_entry_state State information for ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_state_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state  # noqa: E501

        OperationId: get_acl_entry_state State information for ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_state_description(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state_description  # noqa: E501

        OperationId: get_acl_entry_state_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_description(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryStateDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_state_description_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_state_description_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_state_description_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state_description  # noqa: E501

        OperationId: get_acl_entry_state_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_description_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryStateDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_state_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_state_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_state_description`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_state_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/state/description', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryStateDescription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_state_matched_octets(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state_matched_octets  # noqa: E501

        OperationId: get_acl_entry_state_matched_octets Count of the number of octets (bytes) matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_matched_octets(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntryStateMatchedOctets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_state_matched_octets_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_state_matched_octets_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_state_matched_octets_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state_matched_octets  # noqa: E501

        OperationId: get_acl_entry_state_matched_octets Count of the number of octets (bytes) matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_matched_octets_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntryStateMatchedOctets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_state_matched_octets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_acl_entry_state_matched_octets`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_acl_entry_state_matched_octets`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_state_matched_octets`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_state_matched_octets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}/state/matched-octets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryStateMatchedOctets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_state_matched_packets(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state_matched_packets  # noqa: E501

        OperationId: get_acl_entry_state_matched_packets Count of the number of packets matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_matched_packets(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntryStateMatchedPackets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_state_matched_packets_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_state_matched_packets_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_state_matched_packets_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state_matched_packets  # noqa: E501

        OperationId: get_acl_entry_state_matched_packets Count of the number of packets matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_matched_packets_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntryStateMatchedPackets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_state_matched_packets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_acl_entry_state_matched_packets`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_acl_entry_state_matched_packets`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_state_matched_packets`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_state_matched_packets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}/state/matched-packets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryStateMatchedPackets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_state_sequence_id(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state_sequence_id  # noqa: E501

        OperationId: get_acl_entry_state_sequence_id Reference to an entry in the ACL set applied to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_sequence_id(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntryStateSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_state_sequence_id_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_state_sequence_id_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_state_sequence_id_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_state_sequence_id  # noqa: E501

        OperationId: get_acl_entry_state_sequence_id Reference to an entry in the ACL set applied to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_state_sequence_id_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetAclEntryStateSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_state_sequence_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_acl_entry_state_sequence_id`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_acl_entry_state_sequence_id`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_state_sequence_id`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_state_sequence_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}/state/sequence-id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryStateSequenceId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_entry_transport(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_transport  # noqa: E501

        OperationId: get_acl_entry_transport Transport fields container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_transport(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryTransport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_entry_transport_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_entry_transport_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_entry_transport_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_entry_transport  # noqa: E501

        OperationId: get_acl_entry_transport Transport fields container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_entry_transport_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclEntryTransport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_entry_transport" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_entry_transport`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclEntryTransport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_interfaces(self, **kwargs):  # noqa: E501
        """get_acl_interfaces  # noqa: E501

        OperationId: get_acl_interfaces Enclosing container for the list of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_interfaces(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetAclInterfaces
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_interfaces_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_interfaces_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_acl_interfaces_with_http_info(self, **kwargs):  # noqa: E501
        """get_acl_interfaces  # noqa: E501

        OperationId: get_acl_interfaces Enclosing container for the list of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_interfaces_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetAclInterfaces
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_interfaces" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclInterfaces',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_interfaces_interface(self, id, **kwargs):  # noqa: E501
        """get_acl_interfaces_interface  # noqa: E501

        OperationId: get_acl_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_interfaces_interface(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetAclInterfacesInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_interfaces_interface_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_interfaces_interface_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_acl_interfaces_interface_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_acl_interfaces_interface  # noqa: E501

        OperationId: get_acl_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_interfaces_interface_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetAclInterfacesInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_acl_interfaces_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclInterfacesInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_set_acl_entries(self, name, type, **kwargs):  # noqa: E501
        """get_acl_set_acl_entries  # noqa: E501

        OperationId: get_acl_set_acl_entries Access list entries container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_set_acl_entries(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetAclSetAclEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_set_acl_entries_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_set_acl_entries_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_acl_set_acl_entries_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_acl_set_acl_entries  # noqa: E501

        OperationId: get_acl_set_acl_entries Access list entries container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_set_acl_entries_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetAclSetAclEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_set_acl_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_set_acl_entries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclSetAclEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_set_acl_entries_acl_entry(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_acl_set_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_set_acl_entries_acl_entry(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_acl_set_acl_entries_acl_entry_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_acl_set_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_set_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_acl_set_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclSetAclEntriesAclEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_set_config(self, name, type, **kwargs):  # noqa: E501
        """get_acl_set_config  # noqa: E501

        OperationId: get_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_set_config(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_set_config_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_set_config_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_acl_set_config_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_acl_set_config  # noqa: E501

        OperationId: get_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_set_config_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclSetConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_set_state(self, name, type, **kwargs):  # noqa: E501
        """get_acl_set_state  # noqa: E501

        OperationId: get_acl_set_state Access list state information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_set_state(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetAclSetState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_set_state_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_set_state_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_acl_set_state_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_acl_set_state  # noqa: E501

        OperationId: get_acl_set_state Access list state information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_set_state_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetAclSetState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_set_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_acl_set_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_acl_set_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclSetState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl_state(self, **kwargs):  # noqa: E501
        """get_acl_state  # noqa: E501

        OperationId: get_acl_state Global operational state data for ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_state(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetAclState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_acl_state_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_state_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_acl_state_with_http_info(self, **kwargs):  # noqa: E501
        """get_acl_state  # noqa: E501

        OperationId: get_acl_state Global operational state data for ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_acl_state_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetAclState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl_state" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAclState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_actions_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_actions_config  # noqa: E501

        OperationId: get_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actions_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetActionsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_actions_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_actions_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_actions_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_actions_config  # noqa: E501

        OperationId: get_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actions_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetActionsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_actions_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_actions_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_actions_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_actions_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetActionsConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_actions_state(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_actions_state  # noqa: E501

        OperationId: get_actions_state State information for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actions_state(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetActionsState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_actions_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_actions_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_actions_state_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_actions_state  # noqa: E501

        OperationId: get_actions_state State information for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actions_state_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetActionsState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_actions_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_actions_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_actions_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_actions_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetActionsState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_description(self, name, type, **kwargs):  # noqa: E501
        """get_config_description  # noqa: E501

        OperationId: get_config_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_description(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetConfigDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_description_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_description_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_config_description_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_config_description  # noqa: E501

        OperationId: get_config_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_description_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetConfigDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/description', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigDescription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_destination_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_address  # noqa: E501

        OperationId: get_config_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_destination_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_address  # noqa: E501

        OperationId: get_config_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/destination-address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigDestinationAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_destination_flow_label(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_flow_label  # noqa: E501

        OperationId: get_config_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_flow_label(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_destination_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_destination_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_destination_flow_label_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_flow_label  # noqa: E501

        OperationId: get_config_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_flow_label_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_destination_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_destination_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/destination-flow-label', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigDestinationFlowLabel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_destination_mac(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_mac  # noqa: E501

        OperationId: get_config_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_mac(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationMac
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_destination_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_destination_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_destination_mac_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_mac  # noqa: E501

        OperationId: get_config_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_mac_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationMac
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_destination_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_destination_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/destination-mac', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigDestinationMac',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_destination_mac_mask(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_mac_mask  # noqa: E501

        OperationId: get_config_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_mac_mask(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_destination_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_destination_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_destination_mac_mask_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_mac_mask  # noqa: E501

        OperationId: get_config_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_mac_mask_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_destination_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_destination_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/destination-mac-mask', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigDestinationMacMask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_destination_port(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_port  # noqa: E501

        OperationId: get_config_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_port(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_destination_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_destination_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_destination_port_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_destination_port  # noqa: E501

        OperationId: get_config_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_destination_port_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDestinationPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_destination_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_destination_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_destination_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_destination_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/destination-port', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigDestinationPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_dscp(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_dscp  # noqa: E501

        OperationId: get_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_dscp(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_dscp_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_dscp  # noqa: E501

        OperationId: get_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_dscp_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/dscp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigDscp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_ethertype(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_ethertype  # noqa: E501

        OperationId: get_config_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_ethertype(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigEthertype
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_ethertype_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_ethertype_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_ethertype_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_ethertype  # noqa: E501

        OperationId: get_config_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_ethertype_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigEthertype
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_ethertype" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_ethertype`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_ethertype`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_ethertype`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/ethertype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigEthertype',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_forwarding_action(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_forwarding_action  # noqa: E501

        OperationId: get_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_forwarding_action(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigForwardingAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_forwarding_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_forwarding_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_forwarding_action_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_forwarding_action  # noqa: E501

        OperationId: get_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_forwarding_action_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigForwardingAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_forwarding_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_forwarding_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config/forwarding-action', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigForwardingAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_hop_limit(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_hop_limit  # noqa: E501

        OperationId: get_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_hop_limit(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_hop_limit_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_hop_limit  # noqa: E501

        OperationId: get_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_hop_limit_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/hop-limit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigHopLimit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_id(self, id, **kwargs):  # noqa: E501
        """get_config_id  # noqa: E501

        OperationId: get_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetConfigId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_config_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_config_id  # noqa: E501

        OperationId: get_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetConfigId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_config_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config/id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_interface(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_interface  # noqa: E501

        OperationId: get_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_interface(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_interface_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_interface  # noqa: E501

        OperationId: get_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_interface_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config/interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_log_action(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_log_action  # noqa: E501

        OperationId: get_config_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_log_action(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigLogAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_log_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_log_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_log_action_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_log_action  # noqa: E501

        OperationId: get_config_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_log_action_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigLogAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_log_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_log_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_log_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_log_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config/log-action', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigLogAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_name(self, name, type, **kwargs):  # noqa: E501
        """get_config_name  # noqa: E501

        OperationId: get_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_name(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetConfigName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_name_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_name_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_config_name_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_config_name  # noqa: E501

        OperationId: get_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_name_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetConfigName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_protocol(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_protocol  # noqa: E501

        OperationId: get_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_protocol(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_protocol_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_protocol  # noqa: E501

        OperationId: get_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_protocol_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/protocol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigProtocol',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_sequence_id(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_sequence_id  # noqa: E501

        OperationId: get_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_sequence_id(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_sequence_id_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_sequence_id_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_sequence_id_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_sequence_id  # noqa: E501

        OperationId: get_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_sequence_id_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_sequence_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_sequence_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config/sequence-id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigSequenceId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_set_name(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_config_set_name  # noqa: E501

        OperationId: get_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_set_name(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetConfigSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_config_set_name_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_config_set_name  # noqa: E501

        OperationId: get_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_set_name_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetConfigSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config/set-name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigSetName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_address  # noqa: E501

        OperationId: get_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_source_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_address  # noqa: E501

        OperationId: get_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/source-address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigSourceAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_flow_label(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_flow_label  # noqa: E501

        OperationId: get_config_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_flow_label(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourceFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_source_flow_label_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_flow_label  # noqa: E501

        OperationId: get_config_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_flow_label_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourceFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_source_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/source-flow-label', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigSourceFlowLabel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_mac(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_mac  # noqa: E501

        OperationId: get_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_mac(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourceMac
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_source_mac_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_mac  # noqa: E501

        OperationId: get_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_mac_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourceMac
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_source_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_source_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_source_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/source-mac', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigSourceMac',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_mac_mask(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_mac_mask  # noqa: E501

        OperationId: get_config_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_mac_mask(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourceMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_source_mac_mask_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_mac_mask  # noqa: E501

        OperationId: get_config_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_mac_mask_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourceMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_source_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/source-mac-mask', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigSourceMacMask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_port(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_port  # noqa: E501

        OperationId: get_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_port(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourcePort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_source_port_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_source_port  # noqa: E501

        OperationId: get_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_port_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSourcePort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_source_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_source_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_source_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/source-port', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigSourcePort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_subinterface(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_subinterface  # noqa: E501

        OperationId: get_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_subinterface(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_subinterface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_subinterface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_subinterface_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_subinterface  # noqa: E501

        OperationId: get_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_subinterface_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_subinterface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_subinterface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config/subinterface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigSubinterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_tcp_flags(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_tcp_flags  # noqa: E501

        OperationId: get_config_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_tcp_flags(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigTcpFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_tcp_flags_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_tcp_flags_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_config_tcp_flags_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_config_tcp_flags  # noqa: E501

        OperationId: get_config_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_tcp_flags_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetConfigTcpFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_tcp_flags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_config_tcp_flags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/tcp-flags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigTcpFlags',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_type(self, name, type, **kwargs):  # noqa: E501
        """get_config_type  # noqa: E501

        OperationId: get_config_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_type(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_type_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_type_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_config_type_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_config_type  # noqa: E501

        OperationId: get_config_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_type_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetConfigType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_set_acl_entries(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_acl_entries  # noqa: E501

        OperationId: get_egress_acl_set_acl_entries Enclosing container for list of references to ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_acl_entries(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetAclEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_set_acl_entries_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_set_acl_entries_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_set_acl_entries_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_acl_entries  # noqa: E501

        OperationId: get_egress_acl_set_acl_entries Enclosing container for list of references to ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_acl_entries_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetAclEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_set_acl_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_set_acl_entries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/acl-entries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetAclEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_set_acl_entries_acl_entry_state(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_egress_acl_set_acl_entries_acl_entry_state  # noqa: E501

        OperationId: get_egress_acl_set_acl_entries_acl_entry_state Operational state data for per-interface ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_acl_entries_acl_entry_state(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetEgressAclSetAclEntriesAclEntryState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_set_acl_entries_acl_entry_state_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_set_acl_entries_acl_entry_state_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_set_acl_entries_acl_entry_state_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_egress_acl_set_acl_entries_acl_entry_state  # noqa: E501

        OperationId: get_egress_acl_set_acl_entries_acl_entry_state Operational state data for per-interface ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_acl_entries_acl_entry_state_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetEgressAclSetAclEntriesAclEntryState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_set_acl_entries_acl_entry_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_set_acl_entries_acl_entry_state`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_set_acl_entries_acl_entry_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_set_acl_entries_acl_entry_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_egress_acl_set_acl_entries_acl_entry_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetAclEntriesAclEntryState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_set_config(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_config  # noqa: E501

        OperationId: get_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_config(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_set_config_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_set_config_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_set_config_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_config  # noqa: E501

        OperationId: get_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_config_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_set_config_set_name(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_config_set_name  # noqa: E501

        OperationId: get_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_config_set_name(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetConfigSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_set_config_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_set_config_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_set_config_set_name_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_config_set_name  # noqa: E501

        OperationId: get_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_config_set_name_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetConfigSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_set_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_set_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config/set-name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetConfigSetName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_set_config_type(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_config_type  # noqa: E501

        OperationId: get_egress_acl_set_config_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_config_type(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_set_config_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_set_config_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_set_config_type_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_config_type  # noqa: E501

        OperationId: get_egress_acl_set_config_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_config_type_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_set_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_set_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config/type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetConfigType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_set_state(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_state  # noqa: E501

        OperationId: get_egress_acl_set_state Operational state data for interface egress ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_state(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_set_state_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_set_state_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_set_state_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_state  # noqa: E501

        OperationId: get_egress_acl_set_state Operational state data for interface egress ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_state_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_set_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_set_state`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_set_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_set_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_set_state_set_name(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_state_set_name  # noqa: E501

        OperationId: get_egress_acl_set_state_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_state_set_name(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetStateSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_set_state_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_set_state_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_set_state_set_name_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_state_set_name  # noqa: E501

        OperationId: get_egress_acl_set_state_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_state_set_name_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetStateSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_set_state_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_set_state_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_set_state_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_set_state_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/state/set-name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetStateSetName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_set_state_type(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_state_type  # noqa: E501

        OperationId: get_egress_acl_set_state_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_state_type(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetStateType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_set_state_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_set_state_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_set_state_type_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_egress_acl_set_state_type  # noqa: E501

        OperationId: get_egress_acl_set_state_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_set_state_type_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetEgressAclSetStateType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_set_state_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_set_state_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_set_state_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_set_state_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/state/type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetStateType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry List of ACL entries assigned to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetEgressAclSetsEgressAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry List of ACL entries assigned to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetEgressAclSetsEgressAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_egress_acl_sets_egress_acl_set_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetEgressAclSetsEgressAclSetAclEntriesAclEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ingress_acl_set_acl_entries(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_acl_entries  # noqa: E501

        OperationId: get_ingress_acl_set_acl_entries Enclosing container for list of references to ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_acl_entries(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetAclEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ingress_acl_set_acl_entries_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ingress_acl_set_acl_entries_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_ingress_acl_set_acl_entries_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_acl_entries  # noqa: E501

        OperationId: get_ingress_acl_set_acl_entries Enclosing container for list of references to ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_acl_entries_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetAclEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ingress_acl_set_acl_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_ingress_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_ingress_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ingress_acl_set_acl_entries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/acl-entries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIngressAclSetAclEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ingress_acl_set_config(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_config  # noqa: E501

        OperationId: get_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_config(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ingress_acl_set_config_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ingress_acl_set_config_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_ingress_acl_set_config_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_config  # noqa: E501

        OperationId: get_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_config_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ingress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ingress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIngressAclSetConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ingress_acl_set_config_type(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_config_type  # noqa: E501

        OperationId: get_ingress_acl_set_config_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_config_type(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ingress_acl_set_config_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ingress_acl_set_config_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_ingress_acl_set_config_type_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_config_type  # noqa: E501

        OperationId: get_ingress_acl_set_config_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_config_type_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetConfigType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ingress_acl_set_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ingress_acl_set_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config/type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIngressAclSetConfigType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ingress_acl_set_state(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_state  # noqa: E501

        OperationId: get_ingress_acl_set_state Operational state data for interface ingress ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_state(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ingress_acl_set_state_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ingress_acl_set_state_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_ingress_acl_set_state_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_state  # noqa: E501

        OperationId: get_ingress_acl_set_state Operational state data for interface ingress ACLs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_state_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ingress_acl_set_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_ingress_acl_set_state`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_ingress_acl_set_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ingress_acl_set_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIngressAclSetState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ingress_acl_set_state_type(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_state_type  # noqa: E501

        OperationId: get_ingress_acl_set_state_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_state_type(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetStateType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ingress_acl_set_state_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ingress_acl_set_state_type_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_ingress_acl_set_state_type_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_ingress_acl_set_state_type  # noqa: E501

        OperationId: get_ingress_acl_set_state_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_set_state_type_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetIngressAclSetStateType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ingress_acl_set_state_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_ingress_acl_set_state_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_ingress_acl_set_state_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ingress_acl_set_state_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/state/type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIngressAclSetStateType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry List of ACL entries assigned to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetIngressAclSetsIngressAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry_with_http_info(self, id, set_name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry List of ACL entries assigned to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param int sequence_id: Reference to per-interface acl entry key (required)
        :return: GetIngressAclSetsIngressAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ingress_acl_sets_ingress_acl_set_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/acl-entries/acl-entry={sequence_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIngressAclSetsIngressAclSetAclEntriesAclEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_input_interface_interface_ref(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_input_interface_interface_ref  # noqa: E501

        OperationId: get_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_input_interface_interface_ref(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetInputInterfaceInterfaceRef
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_input_interface_interface_ref_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_input_interface_interface_ref_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_input_interface_interface_ref_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_input_interface_interface_ref  # noqa: E501

        OperationId: get_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_input_interface_interface_ref_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetInputInterfaceInterfaceRef
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_input_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_input_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInputInterfaceInterfaceRef',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_config(self, id, **kwargs):  # noqa: E501
        """get_interface_config  # noqa: E501

        OperationId: get_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_config(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_config_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_config_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_config_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_config  # noqa: E501

        OperationId: get_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_config_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_egress_acl_sets(self, id, **kwargs):  # noqa: E501
        """get_interface_egress_acl_sets  # noqa: E501

        OperationId: get_interface_egress_acl_sets Enclosing container the list of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_egress_acl_sets(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceEgressAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_egress_acl_sets_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_egress_acl_sets_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_egress_acl_sets_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_egress_acl_sets  # noqa: E501

        OperationId: get_interface_egress_acl_sets Enclosing container the list of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_egress_acl_sets_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceEgressAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_egress_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_egress_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceEgressAclSets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_egress_acl_sets_egress_acl_set(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_interface_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: get_interface_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_egress_acl_sets_egress_acl_set(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetInterfaceEgressAclSetsEgressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_interface_egress_acl_sets_egress_acl_set_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_interface_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: get_interface_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetInterfaceEgressAclSetsEgressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceEgressAclSetsEgressAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_ingress_acl_sets(self, id, **kwargs):  # noqa: E501
        """get_interface_ingress_acl_sets  # noqa: E501

        OperationId: get_interface_ingress_acl_sets Enclosing container the list of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ingress_acl_sets(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceIngressAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_ingress_acl_sets_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_ingress_acl_sets_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_ingress_acl_sets_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_ingress_acl_sets  # noqa: E501

        OperationId: get_interface_ingress_acl_sets Enclosing container the list of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ingress_acl_sets_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceIngressAclSets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_ingress_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_ingress_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceIngressAclSets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_ingress_acl_sets_ingress_acl_set(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_interface_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: get_interface_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ingress_acl_sets_ingress_acl_set(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetInterfaceIngressAclSetsIngressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_interface_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_interface_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: get_interface_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetInterfaceIngressAclSetsIngressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceIngressAclSetsIngressAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_interface_ref(self, id, **kwargs):  # noqa: E501
        """get_interface_interface_ref  # noqa: E501

        OperationId: get_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_interface_ref(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceInterfaceRef
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_interface_ref_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_interface_ref_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_interface_ref_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_interface_ref  # noqa: E501

        OperationId: get_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_interface_ref_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceInterfaceRef
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceInterfaceRef',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_interface_ref_config(self, id, **kwargs):  # noqa: E501
        """get_interface_interface_ref_config  # noqa: E501

        OperationId: get_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_interface_ref_config(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceInterfaceRefConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_interface_ref_config_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_interface_ref_config_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_interface_ref_config_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_interface_ref_config  # noqa: E501

        OperationId: get_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_interface_ref_config_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceInterfaceRefConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceInterfaceRefConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_interface_ref_state(self, id, **kwargs):  # noqa: E501
        """get_interface_interface_ref_state  # noqa: E501

        OperationId: get_interface_interface_ref_state Operational state for interface-ref  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_interface_ref_state(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceInterfaceRefState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_interface_ref_state_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_interface_ref_state_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_interface_ref_state_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_interface_ref_state  # noqa: E501

        OperationId: get_interface_interface_ref_state Operational state for interface-ref  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_interface_ref_state_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceInterfaceRefState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_interface_ref_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_interface_ref_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceInterfaceRefState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_ref_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_interface_ref_config  # noqa: E501

        OperationId: get_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetInterfaceRefConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_ref_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_ref_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_interface_ref_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_interface_ref_config  # noqa: E501

        OperationId: get_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetInterfaceRefConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceRefConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_ref_config_interface(self, id, **kwargs):  # noqa: E501
        """get_interface_ref_config_interface  # noqa: E501

        OperationId: get_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_config_interface(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceRefConfigInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_ref_config_interface_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_ref_config_interface_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_ref_config_interface_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_ref_config_interface  # noqa: E501

        OperationId: get_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_config_interface_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceRefConfigInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_ref_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_ref_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config/interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceRefConfigInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_ref_config_subinterface(self, id, **kwargs):  # noqa: E501
        """get_interface_ref_config_subinterface  # noqa: E501

        OperationId: get_interface_ref_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_config_subinterface(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceRefConfigSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_ref_config_subinterface_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_ref_config_subinterface_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_ref_config_subinterface_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_ref_config_subinterface  # noqa: E501

        OperationId: get_interface_ref_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_config_subinterface_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceRefConfigSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_ref_config_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_ref_config_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config/subinterface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceRefConfigSubinterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_ref_state(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_interface_ref_state  # noqa: E501

        OperationId: get_interface_ref_state Operational state for interface-ref  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_state(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetInterfaceRefState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_ref_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_ref_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_interface_ref_state_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_interface_ref_state  # noqa: E501

        OperationId: get_interface_ref_state Operational state for interface-ref  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_state_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetInterfaceRefState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_ref_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_interface_ref_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_interface_ref_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_interface_ref_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceRefState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_ref_state_interface(self, id, **kwargs):  # noqa: E501
        """get_interface_ref_state_interface  # noqa: E501

        OperationId: get_interface_ref_state_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_state_interface(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceRefStateInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_ref_state_interface_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_ref_state_interface_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_ref_state_interface_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_ref_state_interface  # noqa: E501

        OperationId: get_interface_ref_state_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_state_interface_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceRefStateInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_ref_state_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_ref_state_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/state/interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceRefStateInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_ref_state_subinterface(self, id, **kwargs):  # noqa: E501
        """get_interface_ref_state_subinterface  # noqa: E501

        OperationId: get_interface_ref_state_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_state_subinterface(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceRefStateSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_ref_state_subinterface_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_ref_state_subinterface_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_ref_state_subinterface_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_ref_state_subinterface  # noqa: E501

        OperationId: get_interface_ref_state_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_ref_state_subinterface_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceRefStateSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_ref_state_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_ref_state_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/state/subinterface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceRefStateSubinterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interface_state(self, id, **kwargs):  # noqa: E501
        """get_interface_state  # noqa: E501

        OperationId: get_interface_state Operational state for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_state(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interface_state_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interface_state_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_interface_state_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_interface_state  # noqa: E501

        OperationId: get_interface_state Operational state for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interface_state_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetInterfaceState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interface_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_interface_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInterfaceState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv4_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv4_config  # noqa: E501

        OperationId: get_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv4_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv4Config
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv4_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv4_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv4_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv4_config  # noqa: E501

        OperationId: get_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv4_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv4Config
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv4_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv4_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv4_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv4_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv4Config',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv4_state(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv4_state  # noqa: E501

        OperationId: get_ipv4_state State information for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv4_state(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv4State
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv4_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv4_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv4_state_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv4_state  # noqa: E501

        OperationId: get_ipv4_state State information for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv4_state_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv4State
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv4_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv4_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv4_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv4_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv4State',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config  # noqa: E501

        OperationId: get_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6Config
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config  # noqa: E501

        OperationId: get_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6Config
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6Config',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_config_destination_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_destination_address  # noqa: E501

        OperationId: get_ipv6_config_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_destination_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_config_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_config_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_config_destination_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_destination_address  # noqa: E501

        OperationId: get_ipv6_config_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_destination_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_config_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_config_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/destination-address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6ConfigDestinationAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_config_dscp(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_dscp  # noqa: E501

        OperationId: get_ipv6_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_dscp(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_config_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_config_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_config_dscp_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_dscp  # noqa: E501

        OperationId: get_ipv6_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_dscp_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_config_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_config_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/dscp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6ConfigDscp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_config_hop_limit(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_hop_limit  # noqa: E501

        OperationId: get_ipv6_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_hop_limit(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_config_hop_limit_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_hop_limit  # noqa: E501

        OperationId: get_ipv6_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_config_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_config_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/hop-limit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6ConfigHopLimit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_config_protocol(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_protocol  # noqa: E501

        OperationId: get_ipv6_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_protocol(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_config_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_config_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_config_protocol_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_protocol  # noqa: E501

        OperationId: get_ipv6_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_protocol_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_config_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_config_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/protocol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6ConfigProtocol',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_config_source_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_source_address  # noqa: E501

        OperationId: get_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_source_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_config_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_config_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_config_source_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_config_source_address  # noqa: E501

        OperationId: get_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_config_source_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6ConfigSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/source-address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6ConfigSourceAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_state(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state  # noqa: E501

        OperationId: get_ipv6_state Operational state data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6State
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_state_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state  # noqa: E501

        OperationId: get_ipv6_state Operational state data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6State
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6State',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_state_destination_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_destination_address  # noqa: E501

        OperationId: get_ipv6_state_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_destination_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_state_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_state_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_state_destination_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_destination_address  # noqa: E501

        OperationId: get_ipv6_state_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_destination_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_state_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_state_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_state_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_state_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/state/destination-address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6StateDestinationAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_state_dscp(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_dscp  # noqa: E501

        OperationId: get_ipv6_state_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_dscp(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_state_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_state_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_state_dscp_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_dscp  # noqa: E501

        OperationId: get_ipv6_state_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_dscp_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_state_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_state_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_state_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_state_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/state/dscp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6StateDscp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_state_hop_limit(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_hop_limit  # noqa: E501

        OperationId: get_ipv6_state_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_hop_limit(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_state_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_state_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_state_hop_limit_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_hop_limit  # noqa: E501

        OperationId: get_ipv6_state_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_hop_limit_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_state_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_state_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_state_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_state_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/state/hop-limit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6StateHopLimit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_state_protocol(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_protocol  # noqa: E501

        OperationId: get_ipv6_state_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_protocol(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_state_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_state_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_state_protocol_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_protocol  # noqa: E501

        OperationId: get_ipv6_state_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_protocol_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_state_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_state_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_state_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_state_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/state/protocol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6StateProtocol',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipv6_state_source_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_source_address  # noqa: E501

        OperationId: get_ipv6_state_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_source_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ipv6_state_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ipv6_state_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_ipv6_state_source_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_ipv6_state_source_address  # noqa: E501

        OperationId: get_ipv6_state_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ipv6_state_source_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetIpv6StateSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipv6_state_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ipv6_state_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_ipv6_state_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_ipv6_state_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/state/source-address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetIpv6StateSourceAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_l2_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_l2_config  # noqa: E501

        OperationId: get_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_l2_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetL2Config
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_l2_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_l2_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_l2_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_l2_config  # noqa: E501

        OperationId: get_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_l2_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetL2Config
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_l2_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_l2_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_l2_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_l2_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetL2Config',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_l2_state(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_l2_state  # noqa: E501

        OperationId: get_l2_state State Information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_l2_state(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetL2State
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_l2_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_l2_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_l2_state_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_l2_state  # noqa: E501

        OperationId: get_l2_state State Information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_l2_state_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetL2State
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_l2_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_l2_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_l2_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_l2_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetL2State',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list_base_acl_entries_acl_entry(self, name, type, **kwargs):  # noqa: E501
        """get_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: get_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_acl_entries_acl_entry(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetListBaseAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_base_acl_entries_acl_entry_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_list_base_acl_entries_acl_entry_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_list_base_acl_entries_acl_entry_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: get_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_acl_entries_acl_entry_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetListBaseAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_base_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_list_base_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_list_base_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListBaseAclEntriesAclEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list_base_acl_sets_acl_set(self, **kwargs):  # noqa: E501
        """get_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: get_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_acl_sets_acl_set(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetListBaseAclSetsAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_base_acl_sets_acl_set_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_list_base_acl_sets_acl_set_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_list_base_acl_sets_acl_set_with_http_info(self, **kwargs):  # noqa: E501
        """get_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: get_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_acl_sets_acl_set_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetListBaseAclSetsAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_base_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListBaseAclSetsAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list_base_egress_acl_set_acl_entries_acl_entry(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_list_base_egress_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_list_base_egress_acl_set_acl_entries_acl_entry List of ACL entries assigned to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_egress_acl_set_acl_entries_acl_entry(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetListBaseEgressAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_base_egress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_list_base_egress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_list_base_egress_acl_set_acl_entries_acl_entry_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_list_base_egress_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_list_base_egress_acl_set_acl_entries_acl_entry List of ACL entries assigned to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_egress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetListBaseEgressAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_base_egress_acl_set_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_list_base_egress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_list_base_egress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_list_base_egress_acl_set_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/acl-entries/acl-entry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListBaseEgressAclSetAclEntriesAclEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list_base_egress_acl_sets_egress_acl_set(self, id, **kwargs):  # noqa: E501
        """get_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: get_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_egress_acl_sets_egress_acl_set(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetListBaseEgressAclSetsEgressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_list_base_egress_acl_sets_egress_acl_set_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: get_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetListBaseEgressAclSetsEgressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_base_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_list_base_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListBaseEgressAclSetsEgressAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list_base_ingress_acl_set_acl_entries_acl_entry(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_list_base_ingress_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_list_base_ingress_acl_set_acl_entries_acl_entry List of ACL entries assigned to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_ingress_acl_set_acl_entries_acl_entry(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetListBaseIngressAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_base_ingress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_list_base_ingress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_list_base_ingress_acl_set_acl_entries_acl_entry_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_list_base_ingress_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: get_list_base_ingress_acl_set_acl_entries_acl_entry List of ACL entries assigned to an interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_ingress_acl_set_acl_entries_acl_entry_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetListBaseIngressAclSetAclEntriesAclEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_base_ingress_acl_set_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_list_base_ingress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_list_base_ingress_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_list_base_ingress_acl_set_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/acl-entries/acl-entry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListBaseIngressAclSetAclEntriesAclEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list_base_ingress_acl_sets_ingress_acl_set(self, id, **kwargs):  # noqa: E501
        """get_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: get_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_ingress_acl_sets_ingress_acl_set(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetListBaseIngressAclSetsIngressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: get_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetListBaseIngressAclSetsIngressAclSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_base_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_list_base_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListBaseIngressAclSetsIngressAclSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list_base_interfaces_interface(self, **kwargs):  # noqa: E501
        """get_list_base_interfaces_interface  # noqa: E501

        OperationId: get_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_interfaces_interface(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetListBaseInterfacesInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_base_interfaces_interface_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_list_base_interfaces_interface_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_list_base_interfaces_interface_with_http_info(self, **kwargs):  # noqa: E501
        """get_list_base_interfaces_interface  # noqa: E501

        OperationId: get_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_base_interfaces_interface_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetListBaseInterfacesInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_base_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListBaseInterfacesInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_counter_capability(self, **kwargs):  # noqa: E501
        """get_state_counter_capability  # noqa: E501

        OperationId: get_state_counter_capability System reported indication of how ACL counters are reported by the target  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_counter_capability(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetStateCounterCapability
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_counter_capability_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_state_counter_capability_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_state_counter_capability_with_http_info(self, **kwargs):  # noqa: E501
        """get_state_counter_capability  # noqa: E501

        OperationId: get_state_counter_capability System reported indication of how ACL counters are reported by the target  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_counter_capability_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetStateCounterCapability
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_counter_capability" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/state/counter-capability', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateCounterCapability',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_description(self, name, type, **kwargs):  # noqa: E501
        """get_state_description  # noqa: E501

        OperationId: get_state_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_description(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetStateDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_description_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_description_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_state_description_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_state_description  # noqa: E501

        OperationId: get_state_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_description_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetStateDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/state/description', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateDescription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_destination_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_address  # noqa: E501

        OperationId: get_state_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_destination_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_destination_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_address  # noqa: E501

        OperationId: get_state_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/state/destination-address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateDestinationAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_destination_flow_label(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_flow_label  # noqa: E501

        OperationId: get_state_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_flow_label(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_destination_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_destination_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_destination_flow_label_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_flow_label  # noqa: E501

        OperationId: get_state_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_flow_label_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_destination_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_destination_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/state/destination-flow-label', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateDestinationFlowLabel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_destination_mac(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_mac  # noqa: E501

        OperationId: get_state_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_mac(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationMac
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_destination_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_destination_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_destination_mac_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_mac  # noqa: E501

        OperationId: get_state_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_mac_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationMac
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_destination_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_destination_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_destination_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_destination_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/state/destination-mac', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateDestinationMac',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_destination_mac_mask(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_mac_mask  # noqa: E501

        OperationId: get_state_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_mac_mask(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_destination_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_destination_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_destination_mac_mask_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_mac_mask  # noqa: E501

        OperationId: get_state_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_mac_mask_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_destination_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_destination_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/state/destination-mac-mask', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateDestinationMacMask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_destination_port(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_port  # noqa: E501

        OperationId: get_state_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_port(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_destination_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_destination_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_destination_port_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_destination_port  # noqa: E501

        OperationId: get_state_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_destination_port_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDestinationPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_destination_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_destination_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_destination_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_destination_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/state/destination-port', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateDestinationPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_dscp(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_dscp  # noqa: E501

        OperationId: get_state_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_dscp(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_dscp_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_dscp_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_dscp  # noqa: E501

        OperationId: get_state_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_dscp_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateDscp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/state/dscp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateDscp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_ethertype(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_ethertype  # noqa: E501

        OperationId: get_state_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_ethertype(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateEthertype
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_ethertype_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_ethertype_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_ethertype_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_ethertype  # noqa: E501

        OperationId: get_state_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_ethertype_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateEthertype
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_ethertype" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_ethertype`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_ethertype`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_ethertype`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/state/ethertype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateEthertype',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_forwarding_action(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_forwarding_action  # noqa: E501

        OperationId: get_state_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_forwarding_action(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateForwardingAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_forwarding_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_forwarding_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_forwarding_action_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_forwarding_action  # noqa: E501

        OperationId: get_state_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_forwarding_action_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateForwardingAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_forwarding_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_forwarding_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_forwarding_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_forwarding_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/state/forwarding-action', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateForwardingAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_hop_limit(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_hop_limit  # noqa: E501

        OperationId: get_state_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_hop_limit(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_hop_limit_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_hop_limit_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_hop_limit  # noqa: E501

        OperationId: get_state_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_hop_limit_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateHopLimit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/state/hop-limit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateHopLimit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_id(self, id, **kwargs):  # noqa: E501
        """get_state_id  # noqa: E501

        OperationId: get_state_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetStateId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_state_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_state_id  # noqa: E501

        OperationId: get_state_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :return: GetStateId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_state_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/state/id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_interface(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_interface  # noqa: E501

        OperationId: get_state_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_interface(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_interface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_interface_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_interface  # noqa: E501

        OperationId: get_state_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_interface_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/state/interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_log_action(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_log_action  # noqa: E501

        OperationId: get_state_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_log_action(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateLogAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_log_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_log_action_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_log_action_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_log_action  # noqa: E501

        OperationId: get_state_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_log_action_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateLogAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_log_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_log_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_log_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_log_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/state/log-action', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateLogAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_matched_octets(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_matched_octets  # noqa: E501

        OperationId: get_state_matched_octets Count of the number of octets (bytes) matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_matched_octets(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateMatchedOctets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_matched_octets_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_matched_octets_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_matched_octets_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_matched_octets  # noqa: E501

        OperationId: get_state_matched_octets Count of the number of octets (bytes) matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_matched_octets_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateMatchedOctets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_matched_octets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_matched_octets`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_matched_octets`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_matched_octets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/state/matched-octets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateMatchedOctets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_matched_packets(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_matched_packets  # noqa: E501

        OperationId: get_state_matched_packets Count of the number of packets matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_matched_packets(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateMatchedPackets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_matched_packets_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_matched_packets_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_matched_packets_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_matched_packets  # noqa: E501

        OperationId: get_state_matched_packets Count of the number of packets matching the current ACL entry.  An implementation should provide this counter on a per-interface per-ACL-entry if possible.  If an implementation only supports ACL counters per entry (i.e., not broken out per interface), then the value should be equal to the aggregate count across all interfaces.  An implementation that provides counters per entry per interface is not required to also provide an aggregate count, e.g., per entry -- the user is expected to be able implement the required aggregation if such a count is needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_matched_packets_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateMatchedPackets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_matched_packets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_matched_packets`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_matched_packets`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_matched_packets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/state/matched-packets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateMatchedPackets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_name(self, name, type, **kwargs):  # noqa: E501
        """get_state_name  # noqa: E501

        OperationId: get_state_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_name(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetStateName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_name_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_name_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_state_name_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_state_name  # noqa: E501

        OperationId: get_state_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_name_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetStateName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/state/name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_protocol(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_protocol  # noqa: E501

        OperationId: get_state_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_protocol(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_protocol_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_protocol_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_protocol  # noqa: E501

        OperationId: get_state_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_protocol_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateProtocol
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/state/protocol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateProtocol',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_sequence_id(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_sequence_id  # noqa: E501

        OperationId: get_state_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_sequence_id(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_sequence_id_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_sequence_id_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_sequence_id_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_sequence_id  # noqa: E501

        OperationId: get_state_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_sequence_id_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSequenceId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_sequence_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_sequence_id`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_sequence_id`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_sequence_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/state/sequence-id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateSequenceId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_set_name(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_state_set_name  # noqa: E501

        OperationId: get_state_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_set_name(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetStateSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_set_name_with_http_info(id, set_name, type, **kwargs)  # noqa: E501
            return data

    def get_state_set_name_with_http_info(self, id, set_name, type, **kwargs):  # noqa: E501
        """get_state_set_name  # noqa: E501

        OperationId: get_state_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_set_name_with_http_info(id, set_name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :return: GetStateSetName
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_state_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `get_state_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/state/set-name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateSetName',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_source_address(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_address  # noqa: E501

        OperationId: get_state_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_address(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_source_address_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_source_address_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_address  # noqa: E501

        OperationId: get_state_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_address_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourceAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/state/source-address', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateSourceAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_source_flow_label(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_flow_label  # noqa: E501

        OperationId: get_state_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_flow_label(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourceFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_source_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_source_flow_label_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_source_flow_label_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_flow_label  # noqa: E501

        OperationId: get_state_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_flow_label_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourceFlowLabel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_source_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_source_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_source_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_source_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/state/source-flow-label', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateSourceFlowLabel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_source_mac(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_mac  # noqa: E501

        OperationId: get_state_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_mac(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourceMac
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_source_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_source_mac_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_source_mac_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_mac  # noqa: E501

        OperationId: get_state_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_mac_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourceMac
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_source_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_source_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_source_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_source_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/state/source-mac', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateSourceMac',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_source_mac_mask(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_mac_mask  # noqa: E501

        OperationId: get_state_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_mac_mask(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourceMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_source_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_source_mac_mask_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_source_mac_mask_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_mac_mask  # noqa: E501

        OperationId: get_state_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_mac_mask_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourceMacMask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_source_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_source_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/state/source-mac-mask', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateSourceMacMask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_source_port(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_port  # noqa: E501

        OperationId: get_state_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_port(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourcePort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_source_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_source_port_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_source_port_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_source_port  # noqa: E501

        OperationId: get_state_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_source_port_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSourcePort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_source_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_source_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_source_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_source_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/state/source-port', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateSourcePort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_subinterface(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_subinterface  # noqa: E501

        OperationId: get_state_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_subinterface(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_subinterface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_subinterface_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_subinterface_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_subinterface  # noqa: E501

        OperationId: get_state_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_subinterface_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateSubinterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_subinterface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_subinterface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/state/subinterface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateSubinterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_tcp_flags(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_tcp_flags  # noqa: E501

        OperationId: get_state_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_tcp_flags(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateTcpFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_tcp_flags_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_tcp_flags_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_state_tcp_flags_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_state_tcp_flags  # noqa: E501

        OperationId: get_state_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_tcp_flags_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetStateTcpFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_tcp_flags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_tcp_flags`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_tcp_flags`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_state_tcp_flags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/state/tcp-flags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateTcpFlags',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_type(self, name, type, **kwargs):  # noqa: E501
        """get_state_type  # noqa: E501

        OperationId: get_state_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_type(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetStateType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_type_with_http_info(name, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_type_with_http_info(name, type, **kwargs)  # noqa: E501
            return data

    def get_state_type_with_http_info(self, name, type, **kwargs):  # noqa: E501
        """get_state_type  # noqa: E501

        OperationId: get_state_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_type_with_http_info(name, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :return: GetStateType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_state_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_state_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/state/type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetStateType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_config(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_transport_config  # noqa: E501

        OperationId: get_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_config(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetTransportConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transport_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_config_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_transport_config_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_transport_config  # noqa: E501

        OperationId: get_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_config_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetTransportConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_transport_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_transport_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_transport_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetTransportConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_state(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_transport_state  # noqa: E501

        OperationId: get_transport_state State data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_state(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetTransportState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transport_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_state_with_http_info(name, type, sequence_id, **kwargs)  # noqa: E501
            return data

    def get_transport_state_with_http_info(self, name, type, sequence_id, **kwargs):  # noqa: E501
        """get_transport_state  # noqa: E501

        OperationId: get_transport_state State data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_state_with_http_info(name, type, sequence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :return: GetTransportState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_transport_state`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_transport_state`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `get_transport_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetTransportState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl(self, body, **kwargs):  # noqa: E501
        """patch_acl  # noqa: E501

        OperationId: patch_acl Top level enclosing container for ACL model config and operational state data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchAcl body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def patch_acl_with_http_info(self, body, **kwargs):  # noqa: E501
        """patch_acl  # noqa: E501

        OperationId: patch_acl Top level enclosing container for ACL model config and operational state data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchAcl body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_acl_sets(self, body, **kwargs):  # noqa: E501
        """patch_acl_acl_sets  # noqa: E501

        OperationId: patch_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_acl_sets(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchAclAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_acl_sets_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_acl_sets_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def patch_acl_acl_sets_with_http_info(self, body, **kwargs):  # noqa: E501
        """patch_acl_acl_sets  # noqa: E501

        OperationId: patch_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_acl_sets_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchAclAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_acl_sets_acl_set(self, name, type, body, **kwargs):  # noqa: E501
        """patch_acl_acl_sets_acl_set  # noqa: E501

        OperationId: patch_acl_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_acl_sets_acl_set(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchAclAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_acl_sets_acl_set_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_acl_sets_acl_set_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_acl_sets_acl_set_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """patch_acl_acl_sets_acl_set  # noqa: E501

        OperationId: patch_acl_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_acl_sets_acl_set_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchAclAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_acl_sets_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_acl_sets_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_acl_sets_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_entry_actions(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_actions  # noqa: E501

        OperationId: patch_acl_entry_actions Enclosing container for list of ACL actions associated with an entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_actions(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryActions body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_entry_actions_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_entry_actions_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_entry_actions_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_actions  # noqa: E501

        OperationId: patch_acl_entry_actions Enclosing container for list of ACL actions associated with an entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_actions_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryActions body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_entry_actions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_entry_actions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_entry_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_config  # noqa: E501

        OperationId: patch_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_entry_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_entry_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_entry_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_config  # noqa: E501

        OperationId: patch_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_entry_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_entry_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_entry_config_description(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_config_description  # noqa: E501

        OperationId: patch_acl_entry_config_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_config_description(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryConfigDescription body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_entry_config_description_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_entry_config_description_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_entry_config_description_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_config_description  # noqa: E501

        OperationId: patch_acl_entry_config_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_config_description_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryConfigDescription body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_entry_config_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_entry_config_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config/description', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_entry_input_interface(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_input_interface  # noqa: E501

        OperationId: patch_acl_entry_input_interface Input interface container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_input_interface(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryInputInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_entry_input_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_entry_input_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_entry_input_interface_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_input_interface  # noqa: E501

        OperationId: patch_acl_entry_input_interface Input interface container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_input_interface_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryInputInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_entry_input_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_entry_input_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_entry_ipv4(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_ipv4  # noqa: E501

        OperationId: patch_acl_entry_ipv4 Top level container for IPv4 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_ipv4(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryIpv4 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_entry_ipv4_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_entry_ipv4_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_entry_ipv4_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_ipv4  # noqa: E501

        OperationId: patch_acl_entry_ipv4 Top level container for IPv4 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_ipv4_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryIpv4 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_entry_ipv4" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_entry_ipv4`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_entry_ipv6(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_ipv6  # noqa: E501

        OperationId: patch_acl_entry_ipv6 Top-level container for IPv6 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_ipv6(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryIpv6 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_entry_ipv6_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_entry_ipv6_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_entry_ipv6_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_ipv6  # noqa: E501

        OperationId: patch_acl_entry_ipv6 Top-level container for IPv6 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_ipv6_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryIpv6 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_entry_ipv6" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_entry_ipv6`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_entry_l2(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_l2  # noqa: E501

        OperationId: patch_acl_entry_l2 Ethernet header fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_l2(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryL2 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_entry_l2_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_entry_l2_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_entry_l2_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_l2  # noqa: E501

        OperationId: patch_acl_entry_l2 Ethernet header fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_l2_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryL2 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_entry_l2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_entry_l2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_entry_transport(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_transport  # noqa: E501

        OperationId: patch_acl_entry_transport Transport fields container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_transport(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryTransport body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_entry_transport_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_entry_transport_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_entry_transport_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_entry_transport  # noqa: E501

        OperationId: patch_acl_entry_transport Transport fields container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_entry_transport_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclEntryTransport body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_entry_transport" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_entry_transport`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_interfaces(self, body, **kwargs):  # noqa: E501
        """patch_acl_interfaces  # noqa: E501

        OperationId: patch_acl_interfaces Enclosing container for the list of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_interfaces(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchAclInterfaces body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_interfaces_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_interfaces_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def patch_acl_interfaces_with_http_info(self, body, **kwargs):  # noqa: E501
        """patch_acl_interfaces  # noqa: E501

        OperationId: patch_acl_interfaces Enclosing container for the list of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_interfaces_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchAclInterfaces body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_interfaces" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_interfaces`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_interfaces_interface(self, id, body, **kwargs):  # noqa: E501
        """patch_acl_interfaces_interface  # noqa: E501

        OperationId: patch_acl_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_interfaces_interface(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchAclInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_interfaces_interface_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_interfaces_interface_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_interfaces_interface_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_acl_interfaces_interface  # noqa: E501

        OperationId: patch_acl_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_interfaces_interface_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchAclInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_acl_interfaces_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_interfaces_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_set_acl_entries(self, name, type, body, **kwargs):  # noqa: E501
        """patch_acl_set_acl_entries  # noqa: E501

        OperationId: patch_acl_set_acl_entries Access list entries container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_set_acl_entries(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchAclSetAclEntries body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_set_acl_entries_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_set_acl_entries_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_set_acl_entries_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """patch_acl_set_acl_entries  # noqa: E501

        OperationId: patch_acl_set_acl_entries Access list entries container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_set_acl_entries_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchAclSetAclEntries body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_set_acl_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_set_acl_entries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_set_acl_entries_acl_entry(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: patch_acl_set_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_set_acl_entries_acl_entry(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclSetAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_set_acl_entries_acl_entry_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: patch_acl_set_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchAclSetAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_set_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_set_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_acl_set_config(self, name, type, body, **kwargs):  # noqa: E501
        """patch_acl_set_config  # noqa: E501

        OperationId: patch_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_set_config(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_acl_set_config_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_acl_set_config_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_acl_set_config_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """patch_acl_set_config  # noqa: E501

        OperationId: patch_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_acl_set_config_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_actions_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_actions_config  # noqa: E501

        OperationId: patch_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_actions_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchActionsConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_actions_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_actions_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_actions_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_actions_config  # noqa: E501

        OperationId: patch_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_actions_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchActionsConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_actions_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_actions_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_actions_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_actions_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_actions_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_description(self, name, type, body, **kwargs):  # noqa: E501
        """patch_config_description  # noqa: E501

        OperationId: patch_config_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_description(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchConfigDescription body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_description_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_description_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_config_description_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """patch_config_description  # noqa: E501

        OperationId: patch_config_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_description_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchConfigDescription body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_description`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/description', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_destination_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_address  # noqa: E501

        OperationId: patch_config_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_destination_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_destination_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_destination_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_address  # noqa: E501

        OperationId: patch_config_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_destination_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/destination-address', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_destination_flow_label(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_flow_label  # noqa: E501

        OperationId: patch_config_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_flow_label(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationFlowLabel body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_destination_flow_label_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_destination_flow_label_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_destination_flow_label_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_flow_label  # noqa: E501

        OperationId: patch_config_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_flow_label_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationFlowLabel body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_destination_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_destination_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/destination-flow-label', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_destination_mac(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_mac  # noqa: E501

        OperationId: patch_config_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_mac(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_destination_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_destination_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_destination_mac_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_mac  # noqa: E501

        OperationId: patch_config_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_mac_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_destination_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_destination_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/destination-mac', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_destination_mac_mask(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_mac_mask  # noqa: E501

        OperationId: patch_config_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_mac_mask(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationMacMask body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_destination_mac_mask_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_destination_mac_mask_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_destination_mac_mask_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_mac_mask  # noqa: E501

        OperationId: patch_config_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_mac_mask_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationMacMask body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_destination_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_destination_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/destination-mac-mask', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_destination_port(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_port  # noqa: E501

        OperationId: patch_config_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_port(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationPort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_destination_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_destination_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_destination_port_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_destination_port  # noqa: E501

        OperationId: patch_config_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_destination_port_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDestinationPort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_destination_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_destination_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_destination_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_destination_port`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_destination_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/destination-port', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_dscp(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_dscp  # noqa: E501

        OperationId: patch_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_dscp(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDscp body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_dscp_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_dscp_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_dscp_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_dscp  # noqa: E501

        OperationId: patch_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_dscp_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigDscp body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_dscp`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/dscp', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_ethertype(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_ethertype  # noqa: E501

        OperationId: patch_config_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_ethertype(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigEthertype body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_ethertype_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_ethertype_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_ethertype_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_ethertype  # noqa: E501

        OperationId: patch_config_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_ethertype_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigEthertype body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_ethertype" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_ethertype`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_ethertype`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_ethertype`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_ethertype`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/ethertype', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_forwarding_action(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_forwarding_action  # noqa: E501

        OperationId: patch_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_forwarding_action(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigForwardingAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_forwarding_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_forwarding_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_forwarding_action_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_forwarding_action  # noqa: E501

        OperationId: patch_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_forwarding_action_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigForwardingAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_forwarding_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_forwarding_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config/forwarding-action', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_hop_limit(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_hop_limit  # noqa: E501

        OperationId: patch_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_hop_limit(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigHopLimit body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_hop_limit_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_hop_limit_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_hop_limit_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_hop_limit  # noqa: E501

        OperationId: patch_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_hop_limit_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigHopLimit body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/hop-limit', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_id(self, id, body, **kwargs):  # noqa: E501
        """patch_config_id  # noqa: E501

        OperationId: patch_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchConfigId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_config_id  # noqa: E501

        OperationId: patch_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchConfigId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_config_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config/id', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_interface(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_interface  # noqa: E501

        OperationId: patch_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_interface(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_interface_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_interface  # noqa: E501

        OperationId: patch_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_interface_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config/interface', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_log_action(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_log_action  # noqa: E501

        OperationId: patch_config_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_log_action(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigLogAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_log_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_log_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_log_action_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_log_action  # noqa: E501

        OperationId: patch_config_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_log_action_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigLogAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_log_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_log_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_log_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_log_action`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_log_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config/log-action', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_name(self, name, type, body, **kwargs):  # noqa: E501
        """patch_config_name  # noqa: E501

        OperationId: patch_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_name(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchConfigName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_name_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_name_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_config_name_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """patch_config_name  # noqa: E501

        OperationId: patch_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_name_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchConfigName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/name', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_protocol(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_protocol  # noqa: E501

        OperationId: patch_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_protocol(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigProtocol body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_protocol_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_protocol_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_protocol_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_protocol  # noqa: E501

        OperationId: patch_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_protocol_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigProtocol body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_protocol`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/protocol', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_sequence_id(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_sequence_id  # noqa: E501

        OperationId: patch_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_sequence_id(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSequenceId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_sequence_id_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_sequence_id_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_sequence_id_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_sequence_id  # noqa: E501

        OperationId: patch_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_sequence_id_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSequenceId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_sequence_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_sequence_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config/sequence-id', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_set_name(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_config_set_name  # noqa: E501

        OperationId: patch_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_set_name(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_config_set_name_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_config_set_name  # noqa: E501

        OperationId: patch_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_set_name_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `patch_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_set_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config/set-name', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_source_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_address  # noqa: E501

        OperationId: patch_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_source_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_address  # noqa: E501

        OperationId: patch_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_source_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/source-address', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_source_flow_label(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_flow_label  # noqa: E501

        OperationId: patch_config_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_flow_label(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourceFlowLabel body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_source_flow_label_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_source_flow_label_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_source_flow_label_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_flow_label  # noqa: E501

        OperationId: patch_config_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_flow_label_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourceFlowLabel body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_source_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_source_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/source-flow-label', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_source_mac(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_mac  # noqa: E501

        OperationId: patch_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_mac(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourceMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_source_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_source_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_source_mac_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_mac  # noqa: E501

        OperationId: patch_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_mac_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourceMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_source_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_source_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_source_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_source_mac`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_source_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/source-mac', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_source_mac_mask(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_mac_mask  # noqa: E501

        OperationId: patch_config_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_mac_mask(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourceMacMask body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_source_mac_mask_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_source_mac_mask_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_source_mac_mask_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_mac_mask  # noqa: E501

        OperationId: patch_config_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_mac_mask_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourceMacMask body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_source_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_source_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/source-mac-mask', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_source_port(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_port  # noqa: E501

        OperationId: patch_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_port(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourcePort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_source_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_source_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_source_port_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_source_port  # noqa: E501

        OperationId: patch_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_port_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSourcePort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_source_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_source_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_source_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_source_port`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_source_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/source-port', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_subinterface(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_subinterface  # noqa: E501

        OperationId: patch_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_subinterface(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSubinterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_subinterface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_subinterface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_subinterface_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_subinterface  # noqa: E501

        OperationId: patch_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_subinterface_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigSubinterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_subinterface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_subinterface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_subinterface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config/subinterface', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_tcp_flags(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_tcp_flags  # noqa: E501

        OperationId: patch_config_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_tcp_flags(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigTcpFlags body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_tcp_flags_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_tcp_flags_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_config_tcp_flags_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_config_tcp_flags  # noqa: E501

        OperationId: patch_config_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_tcp_flags_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchConfigTcpFlags body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_tcp_flags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_tcp_flags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/tcp-flags', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_type(self, name, type, body, **kwargs):  # noqa: E501
        """patch_config_type  # noqa: E501

        OperationId: patch_config_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_type(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_type_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_type_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_config_type_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """patch_config_type  # noqa: E501

        OperationId: patch_config_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_type_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_config_type`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/type', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_egress_acl_set_config(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_egress_acl_set_config  # noqa: E501

        OperationId: patch_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_egress_acl_set_config(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchEgressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_egress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_egress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_egress_acl_set_config_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_egress_acl_set_config  # noqa: E501

        OperationId: patch_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_egress_acl_set_config_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchEgressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_egress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `patch_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_egress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_egress_acl_set_config_set_name(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_egress_acl_set_config_set_name  # noqa: E501

        OperationId: patch_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_egress_acl_set_config_set_name(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchEgressAclSetConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_egress_acl_set_config_set_name_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_egress_acl_set_config_set_name  # noqa: E501

        OperationId: patch_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchEgressAclSetConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_egress_acl_set_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `patch_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_egress_acl_set_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config/set-name', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_egress_acl_set_config_type(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_egress_acl_set_config_type  # noqa: E501

        OperationId: patch_egress_acl_set_config_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_egress_acl_set_config_type(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchEgressAclSetConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_egress_acl_set_config_type_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_egress_acl_set_config_type_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_egress_acl_set_config_type_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_egress_acl_set_config_type  # noqa: E501

        OperationId: patch_egress_acl_set_config_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_egress_acl_set_config_type_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchEgressAclSetConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_egress_acl_set_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `patch_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_egress_acl_set_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config/type', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ingress_acl_set_config(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_ingress_acl_set_config  # noqa: E501

        OperationId: patch_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ingress_acl_set_config(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchIngressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ingress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ingress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_ingress_acl_set_config_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_ingress_acl_set_config  # noqa: E501

        OperationId: patch_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ingress_acl_set_config_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchIngressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ingress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `patch_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ingress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ingress_acl_set_config_type(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_ingress_acl_set_config_type  # noqa: E501

        OperationId: patch_ingress_acl_set_config_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ingress_acl_set_config_type(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchIngressAclSetConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ingress_acl_set_config_type_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ingress_acl_set_config_type_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_ingress_acl_set_config_type_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_ingress_acl_set_config_type  # noqa: E501

        OperationId: patch_ingress_acl_set_config_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ingress_acl_set_config_type_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchIngressAclSetConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ingress_acl_set_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `patch_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ingress_acl_set_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config/type', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_input_interface_interface_ref(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_input_interface_interface_ref  # noqa: E501

        OperationId: patch_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_input_interface_interface_ref(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchInputInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_input_interface_interface_ref_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_input_interface_interface_ref  # noqa: E501

        OperationId: patch_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchInputInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_input_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_input_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_config(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_config  # noqa: E501

        OperationId: patch_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_config(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_config_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_config_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_config_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_config  # noqa: E501

        OperationId: patch_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_config_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_egress_acl_sets(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_egress_acl_sets  # noqa: E501

        OperationId: patch_interface_egress_acl_sets Enclosing container the list of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_egress_acl_sets(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceEgressAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_egress_acl_sets_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_egress_acl_sets_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_egress_acl_sets_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_egress_acl_sets  # noqa: E501

        OperationId: patch_interface_egress_acl_sets Enclosing container the list of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_egress_acl_sets_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceEgressAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_egress_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_egress_acl_sets`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_egress_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_egress_acl_sets_egress_acl_set(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_interface_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: patch_interface_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_egress_acl_sets_egress_acl_set(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchInterfaceEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_egress_acl_sets_egress_acl_set_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_interface_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: patch_interface_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchInterfaceEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `patch_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_ingress_acl_sets(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_ingress_acl_sets  # noqa: E501

        OperationId: patch_interface_ingress_acl_sets Enclosing container the list of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ingress_acl_sets(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceIngressAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_ingress_acl_sets_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_ingress_acl_sets_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_ingress_acl_sets_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_ingress_acl_sets  # noqa: E501

        OperationId: patch_interface_ingress_acl_sets Enclosing container the list of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ingress_acl_sets_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceIngressAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_ingress_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_ingress_acl_sets`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_ingress_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_ingress_acl_sets_ingress_acl_set(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_interface_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: patch_interface_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ingress_acl_sets_ingress_acl_set(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchInterfaceIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """patch_interface_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: patch_interface_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PatchInterfaceIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `patch_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_interface_ref(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_interface_ref  # noqa: E501

        OperationId: patch_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_interface_ref(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_interface_ref_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_interface_ref_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_interface_ref_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_interface_ref  # noqa: E501

        OperationId: patch_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_interface_ref_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_interface_ref_config(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_interface_ref_config  # noqa: E501

        OperationId: patch_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_interface_ref_config(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_interface_ref_config_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_interface_ref_config_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_interface_ref_config_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_interface_ref_config  # noqa: E501

        OperationId: patch_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_interface_ref_config_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_ref_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_interface_ref_config  # noqa: E501

        OperationId: patch_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ref_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_ref_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_ref_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_ref_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_interface_ref_config  # noqa: E501

        OperationId: patch_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ref_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_ref_config_interface(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_ref_config_interface  # noqa: E501

        OperationId: patch_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ref_config_interface(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceRefConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_ref_config_interface_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_ref_config_interface_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_ref_config_interface_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_ref_config_interface  # noqa: E501

        OperationId: patch_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ref_config_interface_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceRefConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_ref_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_ref_config_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_ref_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config/interface', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_interface_ref_config_subinterface(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_ref_config_subinterface  # noqa: E501

        OperationId: patch_interface_ref_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ref_config_subinterface(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceRefConfigSubinterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_interface_ref_config_subinterface_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_interface_ref_config_subinterface_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_interface_ref_config_subinterface_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_interface_ref_config_subinterface  # noqa: E501

        OperationId: patch_interface_ref_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_interface_ref_config_subinterface_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchInterfaceRefConfigSubinterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_interface_ref_config_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_interface_ref_config_subinterface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_interface_ref_config_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config/subinterface', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ipv4_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv4_config  # noqa: E501

        OperationId: patch_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv4_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv4Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ipv4_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ipv4_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_ipv4_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv4_config  # noqa: E501

        OperationId: patch_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv4_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv4Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ipv4_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_ipv4_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ipv4_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_ipv4_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ipv4_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ipv6_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config  # noqa: E501

        OperationId: patch_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ipv6_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ipv6_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_ipv6_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config  # noqa: E501

        OperationId: patch_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ipv6_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_ipv6_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ipv6_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_ipv6_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ipv6_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ipv6_config_destination_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_destination_address  # noqa: E501

        OperationId: patch_ipv6_config_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_destination_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigDestinationAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ipv6_config_destination_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ipv6_config_destination_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_ipv6_config_destination_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_destination_address  # noqa: E501

        OperationId: patch_ipv6_config_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_destination_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigDestinationAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ipv6_config_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ipv6_config_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/destination-address', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ipv6_config_dscp(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_dscp  # noqa: E501

        OperationId: patch_ipv6_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_dscp(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigDscp body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ipv6_config_dscp_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ipv6_config_dscp_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_ipv6_config_dscp_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_dscp  # noqa: E501

        OperationId: patch_ipv6_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_dscp_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigDscp body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ipv6_config_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ipv6_config_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/dscp', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ipv6_config_hop_limit(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_hop_limit  # noqa: E501

        OperationId: patch_ipv6_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_hop_limit(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigHopLimit body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_ipv6_config_hop_limit_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_hop_limit  # noqa: E501

        OperationId: patch_ipv6_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigHopLimit body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ipv6_config_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ipv6_config_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/hop-limit', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ipv6_config_protocol(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_protocol  # noqa: E501

        OperationId: patch_ipv6_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_protocol(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigProtocol body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ipv6_config_protocol_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ipv6_config_protocol_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_ipv6_config_protocol_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_protocol  # noqa: E501

        OperationId: patch_ipv6_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_protocol_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigProtocol body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ipv6_config_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ipv6_config_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/protocol', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ipv6_config_source_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_source_address  # noqa: E501

        OperationId: patch_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_source_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_ipv6_config_source_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_ipv6_config_source_address  # noqa: E501

        OperationId: patch_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchIpv6ConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ipv6_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ipv6_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/source-address', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_l2_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_l2_config  # noqa: E501

        OperationId: patch_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_l2_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchL2Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_l2_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_l2_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_l2_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_l2_config  # noqa: E501

        OperationId: patch_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_l2_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchL2Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_l2_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_l2_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_l2_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_l2_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_l2_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_list_base_acl_entries_acl_entry(self, name, type, body, **kwargs):  # noqa: E501
        """patch_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: patch_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_acl_entries_acl_entry(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchListBaseAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_list_base_acl_entries_acl_entry_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_list_base_acl_entries_acl_entry_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def patch_list_base_acl_entries_acl_entry_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """patch_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: patch_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_acl_entries_acl_entry_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PatchListBaseAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_list_base_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_list_base_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_list_base_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_list_base_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_list_base_acl_sets_acl_set(self, body, **kwargs):  # noqa: E501
        """patch_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: patch_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_acl_sets_acl_set(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchListBaseAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_list_base_acl_sets_acl_set_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_list_base_acl_sets_acl_set_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def patch_list_base_acl_sets_acl_set_with_http_info(self, body, **kwargs):  # noqa: E501
        """patch_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: patch_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_acl_sets_acl_set_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchListBaseAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_list_base_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_list_base_acl_sets_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_list_base_egress_acl_sets_egress_acl_set(self, id, body, **kwargs):  # noqa: E501
        """patch_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: patch_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_egress_acl_sets_egress_acl_set(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchListBaseEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_list_base_egress_acl_sets_egress_acl_set_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: patch_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchListBaseEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_list_base_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_list_base_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_list_base_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_list_base_ingress_acl_sets_ingress_acl_set(self, id, body, **kwargs):  # noqa: E501
        """patch_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: patch_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_ingress_acl_sets_ingress_acl_set(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchListBaseIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """patch_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: patch_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PatchListBaseIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_list_base_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_list_base_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_list_base_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_list_base_interfaces_interface(self, body, **kwargs):  # noqa: E501
        """patch_list_base_interfaces_interface  # noqa: E501

        OperationId: patch_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_interfaces_interface(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchListBaseInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_list_base_interfaces_interface_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_list_base_interfaces_interface_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def patch_list_base_interfaces_interface_with_http_info(self, body, **kwargs):  # noqa: E501
        """patch_list_base_interfaces_interface  # noqa: E501

        OperationId: patch_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_list_base_interfaces_interface_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PatchListBaseInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_list_base_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_list_base_interfaces_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_transport_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_transport_config  # noqa: E501

        OperationId: patch_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_transport_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchTransportConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_transport_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_transport_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def patch_transport_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """patch_transport_config  # noqa: E501

        OperationId: patch_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_transport_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PatchTransportConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_transport_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_transport_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `patch_transport_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `patch_transport_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_transport_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_acl_acl_sets(self, body, **kwargs):  # noqa: E501
        """post_acl_acl_sets  # noqa: E501

        OperationId: post_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_acl_acl_sets(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostAclAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_acl_acl_sets_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_acl_acl_sets_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_acl_acl_sets_with_http_info(self, body, **kwargs):  # noqa: E501
        """post_acl_acl_sets  # noqa: E501

        OperationId: post_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_acl_acl_sets_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostAclAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_acl_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_acl_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_acl_entry_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_acl_entry_config  # noqa: E501

        OperationId: post_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_acl_entry_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostAclEntryConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_acl_entry_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_acl_entry_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_acl_entry_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_acl_entry_config  # noqa: E501

        OperationId: post_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_acl_entry_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostAclEntryConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_acl_entry_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_acl_entry_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_acl_set_config(self, name, type, body, **kwargs):  # noqa: E501
        """post_acl_set_config  # noqa: E501

        OperationId: post_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_acl_set_config(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PostAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_acl_set_config_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_acl_set_config_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def post_acl_set_config_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """post_acl_set_config  # noqa: E501

        OperationId: post_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_acl_set_config_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PostAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_actions_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_actions_config  # noqa: E501

        OperationId: post_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_actions_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostActionsConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_actions_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_actions_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_actions_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_actions_config  # noqa: E501

        OperationId: post_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_actions_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostActionsConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_actions_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_actions_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_actions_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_actions_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_actions_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_forwarding_action(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_forwarding_action  # noqa: E501

        OperationId: post_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_forwarding_action(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigForwardingAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_forwarding_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_forwarding_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_config_forwarding_action_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_forwarding_action  # noqa: E501

        OperationId: post_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_forwarding_action_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigForwardingAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_forwarding_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_forwarding_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_id(self, id, body, **kwargs):  # noqa: E501
        """post_config_id  # noqa: E501

        OperationId: post_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostConfigId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def post_config_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """post_config_id  # noqa: E501

        OperationId: post_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostConfigId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_config_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_interface(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_interface  # noqa: E501

        OperationId: post_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_interface(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_config_interface_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_interface  # noqa: E501

        OperationId: post_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_interface_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_config_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_config_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_config_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_name(self, name, type, body, **kwargs):  # noqa: E501
        """post_config_name  # noqa: E501

        OperationId: post_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_name(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PostConfigName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_name_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_name_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def post_config_name_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """post_config_name  # noqa: E501

        OperationId: post_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_name_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PostConfigName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_config_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_config_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_sequence_id(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_sequence_id  # noqa: E501

        OperationId: post_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_sequence_id(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigSequenceId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_sequence_id_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_sequence_id_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_config_sequence_id_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_sequence_id  # noqa: E501

        OperationId: post_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_sequence_id_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigSequenceId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_sequence_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_sequence_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_set_name(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """post_config_set_name  # noqa: E501

        OperationId: post_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_set_name(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PostConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def post_config_set_name_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """post_config_set_name  # noqa: E501

        OperationId: post_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_set_name_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PostConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `post_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_config_set_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_source_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_source_address  # noqa: E501

        OperationId: post_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_source_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_config_source_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_source_address  # noqa: E501

        OperationId: post_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_source_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_config_source_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_source_mac(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_source_mac  # noqa: E501

        OperationId: post_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_source_mac(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigSourceMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_source_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_source_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_config_source_mac_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_source_mac  # noqa: E501

        OperationId: post_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_source_mac_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigSourceMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_source_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_config_source_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_config_source_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_config_source_mac`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_source_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_source_port(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_source_port  # noqa: E501

        OperationId: post_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_source_port(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigSourcePort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_source_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_source_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_config_source_port_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_config_source_port  # noqa: E501

        OperationId: post_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_source_port_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostConfigSourcePort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_source_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_config_source_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_config_source_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_config_source_port`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_config_source_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_egress_acl_set_config(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """post_egress_acl_set_config  # noqa: E501

        OperationId: post_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_egress_acl_set_config(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PostEgressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_egress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_egress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def post_egress_acl_set_config_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """post_egress_acl_set_config  # noqa: E501

        OperationId: post_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_egress_acl_set_config_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PostEgressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_egress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `post_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_egress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_egress_acl_set_config_set_name(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """post_egress_acl_set_config_set_name  # noqa: E501

        OperationId: post_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_egress_acl_set_config_set_name(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PostEgressAclSetConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def post_egress_acl_set_config_set_name_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """post_egress_acl_set_config_set_name  # noqa: E501

        OperationId: post_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PostEgressAclSetConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_egress_acl_set_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `post_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_egress_acl_set_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_ingress_acl_set_config(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """post_ingress_acl_set_config  # noqa: E501

        OperationId: post_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ingress_acl_set_config(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PostIngressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_ingress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_ingress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def post_ingress_acl_set_config_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """post_ingress_acl_set_config  # noqa: E501

        OperationId: post_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ingress_acl_set_config_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PostIngressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_ingress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `post_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_ingress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_input_interface_interface_ref(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_input_interface_interface_ref  # noqa: E501

        OperationId: post_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_input_interface_interface_ref(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostInputInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_input_interface_interface_ref_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_input_interface_interface_ref  # noqa: E501

        OperationId: post_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostInputInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_input_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_input_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_interface_config(self, id, body, **kwargs):  # noqa: E501
        """post_interface_config  # noqa: E501

        OperationId: post_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_interface_config(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostInterfaceConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_interface_config_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_interface_config_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def post_interface_config_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """post_interface_config  # noqa: E501

        OperationId: post_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_interface_config_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostInterfaceConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_interface_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_interface_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_interface_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_interface_interface_ref_config(self, id, body, **kwargs):  # noqa: E501
        """post_interface_interface_ref_config  # noqa: E501

        OperationId: post_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_interface_interface_ref_config(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostInterfaceInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_interface_interface_ref_config_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_interface_interface_ref_config_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def post_interface_interface_ref_config_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """post_interface_interface_ref_config  # noqa: E501

        OperationId: post_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_interface_interface_ref_config_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostInterfaceInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_interface_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_interface_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_interface_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_interface_ref_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_interface_ref_config  # noqa: E501

        OperationId: post_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_interface_ref_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_interface_ref_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_interface_ref_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_interface_ref_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_interface_ref_config  # noqa: E501

        OperationId: post_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_interface_ref_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_interface_ref_config_interface(self, id, body, **kwargs):  # noqa: E501
        """post_interface_ref_config_interface  # noqa: E501

        OperationId: post_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_interface_ref_config_interface(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostInterfaceRefConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_interface_ref_config_interface_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_interface_ref_config_interface_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def post_interface_ref_config_interface_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """post_interface_ref_config_interface  # noqa: E501

        OperationId: post_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_interface_ref_config_interface_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostInterfaceRefConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_interface_ref_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_interface_ref_config_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_interface_ref_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_ipv4_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_ipv4_config  # noqa: E501

        OperationId: post_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ipv4_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostIpv4Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_ipv4_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_ipv4_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_ipv4_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_ipv4_config  # noqa: E501

        OperationId: post_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ipv4_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostIpv4Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_ipv4_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_ipv4_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_ipv4_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_ipv4_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_ipv4_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_ipv6_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_ipv6_config  # noqa: E501

        OperationId: post_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ipv6_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostIpv6Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_ipv6_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_ipv6_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_ipv6_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_ipv6_config  # noqa: E501

        OperationId: post_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ipv6_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostIpv6Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_ipv6_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_ipv6_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_ipv6_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_ipv6_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_ipv6_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_ipv6_config_source_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_ipv6_config_source_address  # noqa: E501

        OperationId: post_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ipv6_config_source_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostIpv6ConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_ipv6_config_source_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_ipv6_config_source_address  # noqa: E501

        OperationId: post_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostIpv6ConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_ipv6_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_ipv6_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_l2_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_l2_config  # noqa: E501

        OperationId: post_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_l2_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostL2Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_l2_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_l2_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_l2_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_l2_config  # noqa: E501

        OperationId: post_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_l2_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostL2Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_l2_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_l2_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_l2_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_l2_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_l2_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_list_base_acl_entries_acl_entry(self, name, type, body, **kwargs):  # noqa: E501
        """post_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: post_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_acl_entries_acl_entry(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PostListBaseAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_list_base_acl_entries_acl_entry_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_list_base_acl_entries_acl_entry_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def post_list_base_acl_entries_acl_entry_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """post_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: post_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_acl_entries_acl_entry_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PostListBaseAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_list_base_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_list_base_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_list_base_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_list_base_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_list_base_acl_sets_acl_set(self, body, **kwargs):  # noqa: E501
        """post_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: post_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_acl_sets_acl_set(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostListBaseAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_list_base_acl_sets_acl_set_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_list_base_acl_sets_acl_set_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_list_base_acl_sets_acl_set_with_http_info(self, body, **kwargs):  # noqa: E501
        """post_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: post_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_acl_sets_acl_set_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostListBaseAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_list_base_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_list_base_acl_sets_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_list_base_egress_acl_sets_egress_acl_set(self, id, body, **kwargs):  # noqa: E501
        """post_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: post_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_egress_acl_sets_egress_acl_set(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostListBaseEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def post_list_base_egress_acl_sets_egress_acl_set_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """post_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: post_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostListBaseEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_list_base_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_list_base_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_list_base_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_list_base_ingress_acl_sets_ingress_acl_set(self, id, body, **kwargs):  # noqa: E501
        """post_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: post_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_ingress_acl_sets_ingress_acl_set(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostListBaseIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def post_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """post_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: post_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PostListBaseIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_list_base_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_list_base_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_list_base_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_list_base_interfaces_interface(self, body, **kwargs):  # noqa: E501
        """post_list_base_interfaces_interface  # noqa: E501

        OperationId: post_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_interfaces_interface(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostListBaseInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_list_base_interfaces_interface_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_list_base_interfaces_interface_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_list_base_interfaces_interface_with_http_info(self, body, **kwargs):  # noqa: E501
        """post_list_base_interfaces_interface  # noqa: E501

        OperationId: post_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_list_base_interfaces_interface_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostListBaseInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_list_base_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_list_base_interfaces_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_transport_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_transport_config  # noqa: E501

        OperationId: post_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_transport_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostTransportConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_transport_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_transport_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def post_transport_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """post_transport_config  # noqa: E501

        OperationId: post_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_transport_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PostTransportConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_transport_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_transport_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `post_transport_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `post_transport_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_transport_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl(self, body, **kwargs):  # noqa: E501
        """put_acl  # noqa: E501

        OperationId: put_acl Top level enclosing container for ACL model config and operational state data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutAcl body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def put_acl_with_http_info(self, body, **kwargs):  # noqa: E501
        """put_acl  # noqa: E501

        OperationId: put_acl Top level enclosing container for ACL model config and operational state data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutAcl body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_acl_sets(self, body, **kwargs):  # noqa: E501
        """put_acl_acl_sets  # noqa: E501

        OperationId: put_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_acl_sets(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutAclAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_acl_sets_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_acl_sets_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def put_acl_acl_sets_with_http_info(self, body, **kwargs):  # noqa: E501
        """put_acl_acl_sets  # noqa: E501

        OperationId: put_acl_acl_sets Access list entries variables enclosing container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_acl_sets_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutAclAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_acl_sets_acl_set(self, name, type, body, **kwargs):  # noqa: E501
        """put_acl_acl_sets_acl_set  # noqa: E501

        OperationId: put_acl_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_acl_sets_acl_set(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutAclAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_acl_sets_acl_set_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_acl_sets_acl_set_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def put_acl_acl_sets_acl_set_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """put_acl_acl_sets_acl_set  # noqa: E501

        OperationId: put_acl_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_acl_sets_acl_set_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutAclAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_acl_sets_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_acl_sets_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_acl_sets_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_entry_actions(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_actions  # noqa: E501

        OperationId: put_acl_entry_actions Enclosing container for list of ACL actions associated with an entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_actions(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryActions body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_entry_actions_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_entry_actions_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_entry_actions_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_actions  # noqa: E501

        OperationId: put_acl_entry_actions Enclosing container for list of ACL actions associated with an entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_actions_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryActions body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_entry_actions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_entry_actions`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_entry_actions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_entry_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_config  # noqa: E501

        OperationId: put_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_entry_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_entry_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_entry_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_config  # noqa: E501

        OperationId: put_acl_entry_config Access list entries config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_entry_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_entry_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_entry_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_entry_config_description(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_config_description  # noqa: E501

        OperationId: put_acl_entry_config_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_config_description(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryConfigDescription body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_entry_config_description_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_entry_config_description_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_entry_config_description_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_config_description  # noqa: E501

        OperationId: put_acl_entry_config_description A user-defined description, or comment, for this Access List Entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_config_description_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryConfigDescription body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_entry_config_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_entry_config_description`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_entry_config_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config/description', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_entry_input_interface(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_input_interface  # noqa: E501

        OperationId: put_acl_entry_input_interface Input interface container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_input_interface(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryInputInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_entry_input_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_entry_input_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_entry_input_interface_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_input_interface  # noqa: E501

        OperationId: put_acl_entry_input_interface Input interface container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_input_interface_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryInputInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_entry_input_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_entry_input_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_entry_input_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_entry_ipv4(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_ipv4  # noqa: E501

        OperationId: put_acl_entry_ipv4 Top level container for IPv4 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_ipv4(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryIpv4 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_entry_ipv4_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_entry_ipv4_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_entry_ipv4_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_ipv4  # noqa: E501

        OperationId: put_acl_entry_ipv4 Top level container for IPv4 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_ipv4_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryIpv4 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_entry_ipv4" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_entry_ipv4`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_entry_ipv4`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_entry_ipv6(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_ipv6  # noqa: E501

        OperationId: put_acl_entry_ipv6 Top-level container for IPv6 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_ipv6(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryIpv6 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_entry_ipv6_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_entry_ipv6_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_entry_ipv6_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_ipv6  # noqa: E501

        OperationId: put_acl_entry_ipv6 Top-level container for IPv6 match field data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_ipv6_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryIpv6 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_entry_ipv6" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_entry_ipv6`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_entry_ipv6`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_entry_l2(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_l2  # noqa: E501

        OperationId: put_acl_entry_l2 Ethernet header fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_l2(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryL2 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_entry_l2_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_entry_l2_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_entry_l2_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_l2  # noqa: E501

        OperationId: put_acl_entry_l2 Ethernet header fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_l2_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryL2 body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_entry_l2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_entry_l2`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_entry_l2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_entry_transport(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_transport  # noqa: E501

        OperationId: put_acl_entry_transport Transport fields container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_transport(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryTransport body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_entry_transport_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_entry_transport_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_entry_transport_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_entry_transport  # noqa: E501

        OperationId: put_acl_entry_transport Transport fields container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_entry_transport_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclEntryTransport body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_entry_transport" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_entry_transport`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_entry_transport`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_interfaces(self, body, **kwargs):  # noqa: E501
        """put_acl_interfaces  # noqa: E501

        OperationId: put_acl_interfaces Enclosing container for the list of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_interfaces(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutAclInterfaces body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_interfaces_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_interfaces_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def put_acl_interfaces_with_http_info(self, body, **kwargs):  # noqa: E501
        """put_acl_interfaces  # noqa: E501

        OperationId: put_acl_interfaces Enclosing container for the list of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_interfaces_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutAclInterfaces body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_interfaces" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_interfaces`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_interfaces_interface(self, id, body, **kwargs):  # noqa: E501
        """put_acl_interfaces_interface  # noqa: E501

        OperationId: put_acl_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_interfaces_interface(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutAclInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_interfaces_interface_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_interfaces_interface_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_interfaces_interface_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_acl_interfaces_interface  # noqa: E501

        OperationId: put_acl_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_interfaces_interface_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutAclInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_acl_interfaces_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_interfaces_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_set_acl_entries(self, name, type, body, **kwargs):  # noqa: E501
        """put_acl_set_acl_entries  # noqa: E501

        OperationId: put_acl_set_acl_entries Access list entries container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_set_acl_entries(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutAclSetAclEntries body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_set_acl_entries_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_set_acl_entries_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def put_acl_set_acl_entries_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """put_acl_set_acl_entries  # noqa: E501

        OperationId: put_acl_set_acl_entries Access list entries container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_set_acl_entries_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutAclSetAclEntries body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_set_acl_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_set_acl_entries`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_set_acl_entries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_set_acl_entries_acl_entry(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: put_acl_set_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_set_acl_entries_acl_entry(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclSetAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_acl_set_acl_entries_acl_entry_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_acl_set_acl_entries_acl_entry  # noqa: E501

        OperationId: put_acl_set_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_set_acl_entries_acl_entry_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutAclSetAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_set_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_acl_set_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_set_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_acl_set_config(self, name, type, body, **kwargs):  # noqa: E501
        """put_acl_set_config  # noqa: E501

        OperationId: put_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_set_config(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_acl_set_config_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_acl_set_config_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def put_acl_set_config_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """put_acl_set_config  # noqa: E501

        OperationId: put_acl_set_config Access list config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_acl_set_config_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_actions_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_actions_config  # noqa: E501

        OperationId: put_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_actions_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutActionsConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_actions_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_actions_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_actions_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_actions_config  # noqa: E501

        OperationId: put_actions_config Config data for ACL actions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_actions_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutActionsConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_actions_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_actions_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_actions_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_actions_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_actions_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_description(self, name, type, body, **kwargs):  # noqa: E501
        """put_config_description  # noqa: E501

        OperationId: put_config_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_description(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutConfigDescription body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_description_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_description_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def put_config_description_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """put_config_description  # noqa: E501

        OperationId: put_config_description Description, or comment, for the ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_description_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutConfigDescription body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_description" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_description`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_description`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_description`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/description', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_destination_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_address  # noqa: E501

        OperationId: put_config_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_destination_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_destination_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_destination_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_address  # noqa: E501

        OperationId: put_config_destination_address Destination IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_destination_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/destination-address', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_destination_flow_label(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_flow_label  # noqa: E501

        OperationId: put_config_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_flow_label(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationFlowLabel body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_destination_flow_label_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_destination_flow_label_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_destination_flow_label_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_flow_label  # noqa: E501

        OperationId: put_config_destination_flow_label Destination IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_flow_label_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationFlowLabel body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_destination_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_destination_flow_label`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_destination_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/destination-flow-label', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_destination_mac(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_mac  # noqa: E501

        OperationId: put_config_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_mac(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_destination_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_destination_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_destination_mac_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_mac  # noqa: E501

        OperationId: put_config_destination_mac Destination IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_mac_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_destination_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_destination_mac`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_destination_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/destination-mac', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_destination_mac_mask(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_mac_mask  # noqa: E501

        OperationId: put_config_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_mac_mask(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationMacMask body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_destination_mac_mask_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_destination_mac_mask_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_destination_mac_mask_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_mac_mask  # noqa: E501

        OperationId: put_config_destination_mac_mask Destination IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_mac_mask_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationMacMask body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_destination_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_destination_mac_mask`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_destination_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/destination-mac-mask', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_destination_port(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_port  # noqa: E501

        OperationId: put_config_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_port(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationPort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_destination_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_destination_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_destination_port_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_destination_port  # noqa: E501

        OperationId: put_config_destination_port Destination port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_destination_port_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDestinationPort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_destination_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_destination_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_destination_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_destination_port`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_destination_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/destination-port', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_dscp(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_dscp  # noqa: E501

        OperationId: put_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_dscp(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDscp body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_dscp_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_dscp_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_dscp_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_dscp  # noqa: E501

        OperationId: put_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_dscp_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigDscp body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_dscp`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/dscp', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_ethertype(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_ethertype  # noqa: E501

        OperationId: put_config_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_ethertype(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigEthertype body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_ethertype_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_ethertype_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_ethertype_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_ethertype  # noqa: E501

        OperationId: put_config_ethertype Ethertype field to match in Ethernet packets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_ethertype_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigEthertype body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_ethertype" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_ethertype`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_ethertype`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_ethertype`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_ethertype`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/ethertype', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_forwarding_action(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_forwarding_action  # noqa: E501

        OperationId: put_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_forwarding_action(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigForwardingAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_forwarding_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_forwarding_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_forwarding_action_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_forwarding_action  # noqa: E501

        OperationId: put_config_forwarding_action Specifies the forwarding action.  One forwarding action must be specified for each ACL entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_forwarding_action_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigForwardingAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_forwarding_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_forwarding_action`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_forwarding_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config/forwarding-action', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_hop_limit(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_hop_limit  # noqa: E501

        OperationId: put_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_hop_limit(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigHopLimit body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_hop_limit_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_hop_limit_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_hop_limit_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_hop_limit  # noqa: E501

        OperationId: put_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_hop_limit_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigHopLimit body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/hop-limit', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_id(self, id, body, **kwargs):  # noqa: E501
        """put_config_id  # noqa: E501

        OperationId: put_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutConfigId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_config_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_config_id  # noqa: E501

        OperationId: put_config_id User-defined identifier for the interface -- a common convention could be '<if name>.<subif index>'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutConfigId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_config_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config/id', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_interface(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_interface  # noqa: E501

        OperationId: put_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_interface(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_interface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_interface_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_interface  # noqa: E501

        OperationId: put_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_interface_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_interface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_interface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config/interface', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_log_action(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_log_action  # noqa: E501

        OperationId: put_config_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_log_action(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigLogAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_log_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_log_action_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_log_action_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_log_action  # noqa: E501

        OperationId: put_config_log_action Specifies the log action and destination for matched packets.  The default is not to log the packet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_log_action_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigLogAction body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_log_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_log_action`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_log_action`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_log_action`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_log_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/actions/config/log-action', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_name(self, name, type, body, **kwargs):  # noqa: E501
        """put_config_name  # noqa: E501

        OperationId: put_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_name(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutConfigName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_name_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_name_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def put_config_name_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """put_config_name  # noqa: E501

        OperationId: put_config_name The name of the access-list set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_name_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutConfigName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/name', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_protocol(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_protocol  # noqa: E501

        OperationId: put_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_protocol(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigProtocol body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_protocol_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_protocol_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_protocol_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_protocol  # noqa: E501

        OperationId: put_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_protocol_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigProtocol body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_protocol`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/protocol', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_sequence_id(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_sequence_id  # noqa: E501

        OperationId: put_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_sequence_id(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSequenceId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_sequence_id_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_sequence_id_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_sequence_id_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_sequence_id  # noqa: E501

        OperationId: put_config_sequence_id The sequence id determines the order in which ACL entries are applied.  The sequence id must be unique for each entry in an ACL set.  Target devices should apply the ACL entry rules in ascending order determined by sequence id (low to high), rather than the relying only on order in the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_sequence_id_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSequenceId body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_sequence_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_sequence_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_sequence_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/config/sequence-id', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_set_name(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_config_set_name  # noqa: E501

        OperationId: put_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_set_name(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def put_config_set_name_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_config_set_name  # noqa: E501

        OperationId: put_config_set_name Reference to the ACL set name applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_set_name_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `put_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_set_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config/set-name', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_source_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_address  # noqa: E501

        OperationId: put_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_source_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_address  # noqa: E501

        OperationId: put_config_source_address Source IPv4 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_source_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config/source-address', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_source_flow_label(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_flow_label  # noqa: E501

        OperationId: put_config_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_flow_label(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourceFlowLabel body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_source_flow_label_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_source_flow_label_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_source_flow_label_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_flow_label  # noqa: E501

        OperationId: put_config_source_flow_label Source IPv6 Flow label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_flow_label_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourceFlowLabel body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_source_flow_label" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_source_flow_label`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_source_flow_label`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/source-flow-label', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_source_mac(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_mac  # noqa: E501

        OperationId: put_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_mac(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourceMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_source_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_source_mac_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_source_mac_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_mac  # noqa: E501

        OperationId: put_config_source_mac Source IEEE 802 MAC address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_mac_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourceMac body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_source_mac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_source_mac`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_source_mac`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_source_mac`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_source_mac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/source-mac', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_source_mac_mask(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_mac_mask  # noqa: E501

        OperationId: put_config_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_mac_mask(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourceMacMask body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_source_mac_mask_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_source_mac_mask_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_source_mac_mask_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_mac_mask  # noqa: E501

        OperationId: put_config_source_mac_mask Source IEEE 802 MAC address mask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_mac_mask_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourceMacMask body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_source_mac_mask" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_source_mac_mask`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_source_mac_mask`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config/source-mac-mask', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_source_port(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_port  # noqa: E501

        OperationId: put_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_port(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourcePort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_source_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_source_port_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_source_port_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_source_port  # noqa: E501

        OperationId: put_config_source_port Source port or range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_source_port_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSourcePort body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_source_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_source_port`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_source_port`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_source_port`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_source_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/source-port', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_subinterface(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_subinterface  # noqa: E501

        OperationId: put_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_subinterface(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSubinterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_subinterface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_subinterface_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_subinterface_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_subinterface  # noqa: E501

        OperationId: put_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_subinterface_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigSubinterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_subinterface`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_subinterface`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_subinterface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config/subinterface', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_tcp_flags(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_tcp_flags  # noqa: E501

        OperationId: put_config_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_tcp_flags(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigTcpFlags body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_tcp_flags_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_tcp_flags_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_config_tcp_flags_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_config_tcp_flags  # noqa: E501

        OperationId: put_config_tcp_flags List of TCP flags to match  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_tcp_flags_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutConfigTcpFlags body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_tcp_flags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_config_tcp_flags`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_tcp_flags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config/tcp-flags', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_config_type(self, name, type, body, **kwargs):  # noqa: E501
        """put_config_type  # noqa: E501

        OperationId: put_config_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_type(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_config_type_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_config_type_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def put_config_type_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """put_config_type  # noqa: E501

        OperationId: put_config_type The type determines the fields allowed in the ACL entries belonging to the ACL set (e.g., IPv4, IPv6, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_config_type_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_config_type`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/config/type', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_egress_acl_set_config(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_egress_acl_set_config  # noqa: E501

        OperationId: put_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_egress_acl_set_config(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutEgressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_egress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_egress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def put_egress_acl_set_config_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_egress_acl_set_config  # noqa: E501

        OperationId: put_egress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_egress_acl_set_config_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutEgressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_egress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `put_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_egress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_egress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_egress_acl_set_config_set_name(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_egress_acl_set_config_set_name  # noqa: E501

        OperationId: put_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_egress_acl_set_config_set_name(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutEgressAclSetConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def put_egress_acl_set_config_set_name_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_egress_acl_set_config_set_name  # noqa: E501

        OperationId: put_egress_acl_set_config_set_name Reference to the ACL set name applied on egress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_egress_acl_set_config_set_name_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutEgressAclSetConfigSetName body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_egress_acl_set_config_set_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `put_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_egress_acl_set_config_set_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_egress_acl_set_config_set_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config/set-name', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_egress_acl_set_config_type(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_egress_acl_set_config_type  # noqa: E501

        OperationId: put_egress_acl_set_config_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_egress_acl_set_config_type(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutEgressAclSetConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_egress_acl_set_config_type_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_egress_acl_set_config_type_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def put_egress_acl_set_config_type_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_egress_acl_set_config_type  # noqa: E501

        OperationId: put_egress_acl_set_config_type Reference to the ACL set type applied on egress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_egress_acl_set_config_type_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutEgressAclSetConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_egress_acl_set_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `put_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_egress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_egress_acl_set_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}/config/type', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ingress_acl_set_config(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_ingress_acl_set_config  # noqa: E501

        OperationId: put_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ingress_acl_set_config(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutIngressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ingress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ingress_acl_set_config_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def put_ingress_acl_set_config_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_ingress_acl_set_config  # noqa: E501

        OperationId: put_ingress_acl_set_config Configuration data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ingress_acl_set_config_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutIngressAclSetConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ingress_acl_set_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `put_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ingress_acl_set_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ingress_acl_set_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ingress_acl_set_config_type(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_ingress_acl_set_config_type  # noqa: E501

        OperationId: put_ingress_acl_set_config_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ingress_acl_set_config_type(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutIngressAclSetConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ingress_acl_set_config_type_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ingress_acl_set_config_type_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def put_ingress_acl_set_config_type_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_ingress_acl_set_config_type  # noqa: E501

        OperationId: put_ingress_acl_set_config_type Reference to the ACL set type applied on ingress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ingress_acl_set_config_type_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutIngressAclSetConfigType body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ingress_acl_set_config_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `put_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ingress_acl_set_config_type`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ingress_acl_set_config_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}/config/type', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_input_interface_interface_ref(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_input_interface_interface_ref  # noqa: E501

        OperationId: put_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_input_interface_interface_ref(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutInputInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_input_interface_interface_ref_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_input_interface_interface_ref  # noqa: E501

        OperationId: put_input_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_input_interface_interface_ref_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutInputInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_input_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_input_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_input_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_config(self, id, body, **kwargs):  # noqa: E501
        """put_interface_config  # noqa: E501

        OperationId: put_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_config(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_config_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_config_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_interface_config_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_interface_config  # noqa: E501

        OperationId: put_interface_config Configuration for ACL per-interface data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_config_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_egress_acl_sets(self, id, body, **kwargs):  # noqa: E501
        """put_interface_egress_acl_sets  # noqa: E501

        OperationId: put_interface_egress_acl_sets Enclosing container the list of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_egress_acl_sets(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceEgressAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_egress_acl_sets_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_egress_acl_sets_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_interface_egress_acl_sets_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_interface_egress_acl_sets  # noqa: E501

        OperationId: put_interface_egress_acl_sets Enclosing container the list of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_egress_acl_sets_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceEgressAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_egress_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_egress_acl_sets`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_egress_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_egress_acl_sets_egress_acl_set(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_interface_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: put_interface_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_egress_acl_sets_egress_acl_set(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutInterfaceEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def put_interface_egress_acl_sets_egress_acl_set_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_interface_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: put_interface_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_egress_acl_sets_egress_acl_set_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutInterfaceEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `put_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set={set_name},{type}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_ingress_acl_sets(self, id, body, **kwargs):  # noqa: E501
        """put_interface_ingress_acl_sets  # noqa: E501

        OperationId: put_interface_ingress_acl_sets Enclosing container the list of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ingress_acl_sets(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceIngressAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_ingress_acl_sets_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_ingress_acl_sets_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_interface_ingress_acl_sets_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_interface_ingress_acl_sets  # noqa: E501

        OperationId: put_interface_ingress_acl_sets Enclosing container the list of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ingress_acl_sets_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceIngressAclSets body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_ingress_acl_sets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_ingress_acl_sets`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_ingress_acl_sets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_ingress_acl_sets_ingress_acl_set(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_interface_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: put_interface_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ingress_acl_sets_ingress_acl_set(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutInterfaceIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, body, **kwargs)  # noqa: E501
            return data

    def put_interface_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, set_name, type, body, **kwargs):  # noqa: E501
        """put_interface_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: put_interface_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ingress_acl_sets_ingress_acl_set_with_http_info(id, set_name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param str set_name: Reference to set name list key (required)
        :param str type: Reference to type list key (required)
        :param PutInterfaceIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'set_name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'set_name' is set
        if ('set_name' not in params or
                params['set_name'] is None):
            raise ValueError("Missing the required parameter `set_name` when calling `put_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'set_name' in params:
            path_params['set_name'] = params['set_name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set={set_name},{type}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_interface_ref(self, id, body, **kwargs):  # noqa: E501
        """put_interface_interface_ref  # noqa: E501

        OperationId: put_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_interface_ref(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_interface_ref_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_interface_ref_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_interface_interface_ref_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_interface_interface_ref  # noqa: E501

        OperationId: put_interface_interface_ref Reference to an interface or subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_interface_ref_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceInterfaceRef body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_interface_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_interface_ref`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_interface_ref`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_interface_ref_config(self, id, body, **kwargs):  # noqa: E501
        """put_interface_interface_ref_config  # noqa: E501

        OperationId: put_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_interface_ref_config(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_interface_ref_config_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_interface_ref_config_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_interface_interface_ref_config_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_interface_interface_ref_config  # noqa: E501

        OperationId: put_interface_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_interface_ref_config_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_ref_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_interface_ref_config  # noqa: E501

        OperationId: put_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ref_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_ref_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_ref_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_interface_ref_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_interface_ref_config  # noqa: E501

        OperationId: put_interface_ref_config Configured reference to interface / subinterface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ref_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutInterfaceRefConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_ref_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_interface_ref_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_ref_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/input-interface/interface-ref/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_ref_config_interface(self, id, body, **kwargs):  # noqa: E501
        """put_interface_ref_config_interface  # noqa: E501

        OperationId: put_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ref_config_interface(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceRefConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_ref_config_interface_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_ref_config_interface_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_interface_ref_config_interface_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_interface_ref_config_interface  # noqa: E501

        OperationId: put_interface_ref_config_interface Reference to a base interface.  If a reference to a subinterface is required, this leaf must be specified to indicate the base interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ref_config_interface_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceRefConfigInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_ref_config_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_ref_config_interface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_ref_config_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config/interface', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_interface_ref_config_subinterface(self, id, body, **kwargs):  # noqa: E501
        """put_interface_ref_config_subinterface  # noqa: E501

        OperationId: put_interface_ref_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ref_config_subinterface(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceRefConfigSubinterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_interface_ref_config_subinterface_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_interface_ref_config_subinterface_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_interface_ref_config_subinterface_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_interface_ref_config_subinterface  # noqa: E501

        OperationId: put_interface_ref_config_subinterface Reference to a subinterface -- this requires the base interface to be specified using the interface leaf in this container.  If only a reference to a base interface is requuired, this leaf should not be set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_interface_ref_config_subinterface_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutInterfaceRefConfigSubinterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_interface_ref_config_subinterface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_interface_ref_config_subinterface`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_interface_ref_config_subinterface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/interface-ref/config/subinterface', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ipv4_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv4_config  # noqa: E501

        OperationId: put_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv4_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv4Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ipv4_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ipv4_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_ipv4_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv4_config  # noqa: E501

        OperationId: put_ipv4_config Configuration data for IPv4 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv4_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv4Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ipv4_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ipv4_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ipv4_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_ipv4_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ipv4_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv4/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ipv6_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config  # noqa: E501

        OperationId: put_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ipv6_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ipv6_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_ipv6_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config  # noqa: E501

        OperationId: put_ipv6_config Configuration data for IPv6 match fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ipv6_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ipv6_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ipv6_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_ipv6_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ipv6_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ipv6_config_destination_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_destination_address  # noqa: E501

        OperationId: put_ipv6_config_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_destination_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigDestinationAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ipv6_config_destination_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ipv6_config_destination_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_ipv6_config_destination_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_destination_address  # noqa: E501

        OperationId: put_ipv6_config_destination_address Destination IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_destination_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigDestinationAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ipv6_config_destination_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_ipv6_config_destination_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ipv6_config_destination_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/destination-address', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ipv6_config_dscp(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_dscp  # noqa: E501

        OperationId: put_ipv6_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_dscp(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigDscp body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ipv6_config_dscp_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ipv6_config_dscp_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_ipv6_config_dscp_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_dscp  # noqa: E501

        OperationId: put_ipv6_config_dscp Value of diffserv codepoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_dscp_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigDscp body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ipv6_config_dscp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_ipv6_config_dscp`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ipv6_config_dscp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/dscp', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ipv6_config_hop_limit(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_hop_limit  # noqa: E501

        OperationId: put_ipv6_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_hop_limit(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigHopLimit body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_ipv6_config_hop_limit_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_hop_limit  # noqa: E501

        OperationId: put_ipv6_config_hop_limit The IP packet's hop limit -- known as TTL (in hops) in IPv4 packets, and hop limit in IPv6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_hop_limit_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigHopLimit body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ipv6_config_hop_limit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_ipv6_config_hop_limit`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ipv6_config_hop_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/hop-limit', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ipv6_config_protocol(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_protocol  # noqa: E501

        OperationId: put_ipv6_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_protocol(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigProtocol body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ipv6_config_protocol_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ipv6_config_protocol_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_ipv6_config_protocol_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_protocol  # noqa: E501

        OperationId: put_ipv6_config_protocol The protocol carried in the IP packet, expressed either as its IP protocol number, or by a defined identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_protocol_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigProtocol body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ipv6_config_protocol" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_ipv6_config_protocol`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ipv6_config_protocol`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/protocol', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_ipv6_config_source_address(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_source_address  # noqa: E501

        OperationId: put_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_source_address(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_ipv6_config_source_address_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_ipv6_config_source_address  # noqa: E501

        OperationId: put_ipv6_config_source_address Source IPv6 address prefix.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_ipv6_config_source_address_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutIpv6ConfigSourceAddress body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_ipv6_config_source_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_ipv6_config_source_address`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_ipv6_config_source_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/ipv6/config/source-address', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_l2_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_l2_config  # noqa: E501

        OperationId: put_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_l2_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutL2Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_l2_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_l2_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_l2_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_l2_config  # noqa: E501

        OperationId: put_l2_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_l2_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutL2Config body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_l2_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_l2_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_l2_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_l2_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_l2_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/l2/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_list_base_acl_entries_acl_entry(self, name, type, body, **kwargs):  # noqa: E501
        """put_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: put_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_acl_entries_acl_entry(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutListBaseAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_list_base_acl_entries_acl_entry_with_http_info(name, type, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_list_base_acl_entries_acl_entry_with_http_info(name, type, body, **kwargs)  # noqa: E501
            return data

    def put_list_base_acl_entries_acl_entry_with_http_info(self, name, type, body, **kwargs):  # noqa: E501
        """put_list_base_acl_entries_acl_entry  # noqa: E501

        OperationId: put_list_base_acl_entries_acl_entry List of ACL entries comprising an ACL set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_acl_entries_acl_entry_with_http_info(name, type, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param PutListBaseAclEntriesAclEntry body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_list_base_acl_entries_acl_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_list_base_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_list_base_acl_entries_acl_entry`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_list_base_acl_entries_acl_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_list_base_acl_sets_acl_set(self, body, **kwargs):  # noqa: E501
        """put_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: put_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_acl_sets_acl_set(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutListBaseAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_list_base_acl_sets_acl_set_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_list_base_acl_sets_acl_set_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def put_list_base_acl_sets_acl_set_with_http_info(self, body, **kwargs):  # noqa: E501
        """put_list_base_acl_sets_acl_set  # noqa: E501

        OperationId: put_list_base_acl_sets_acl_set List of ACL sets, each comprising of a list of ACL entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_acl_sets_acl_set_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutListBaseAclSetsAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_list_base_acl_sets_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_list_base_acl_sets_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_list_base_egress_acl_sets_egress_acl_set(self, id, body, **kwargs):  # noqa: E501
        """put_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: put_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_egress_acl_sets_egress_acl_set(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutListBaseEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_list_base_egress_acl_sets_egress_acl_set_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_list_base_egress_acl_sets_egress_acl_set  # noqa: E501

        OperationId: put_list_base_egress_acl_sets_egress_acl_set List of egress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_egress_acl_sets_egress_acl_set_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutListBaseEgressAclSetsEgressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_list_base_egress_acl_sets_egress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_list_base_egress_acl_sets_egress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_list_base_egress_acl_sets_egress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/egress-acl-sets/egress-acl-set', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_list_base_ingress_acl_sets_ingress_acl_set(self, id, body, **kwargs):  # noqa: E501
        """put_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: put_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_ingress_acl_sets_ingress_acl_set(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutListBaseIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def put_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """put_list_base_ingress_acl_sets_ingress_acl_set  # noqa: E501

        OperationId: put_list_base_ingress_acl_sets_ingress_acl_set List of ingress ACLs on the interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_ingress_acl_sets_ingress_acl_set_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Reference to the interface id list key (required)
        :param PutListBaseIngressAclSetsIngressAclSet body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_list_base_ingress_acl_sets_ingress_acl_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_list_base_ingress_acl_sets_ingress_acl_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_list_base_ingress_acl_sets_ingress_acl_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface={id}/ingress-acl-sets/ingress-acl-set', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_list_base_interfaces_interface(self, body, **kwargs):  # noqa: E501
        """put_list_base_interfaces_interface  # noqa: E501

        OperationId: put_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_interfaces_interface(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutListBaseInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_list_base_interfaces_interface_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_list_base_interfaces_interface_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def put_list_base_interfaces_interface_with_http_info(self, body, **kwargs):  # noqa: E501
        """put_list_base_interfaces_interface  # noqa: E501

        OperationId: put_list_base_interfaces_interface List of interfaces on which ACLs are set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_list_base_interfaces_interface_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutListBaseInterfacesInterface body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_list_base_interfaces_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_list_base_interfaces_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/interfaces/interface', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_transport_config(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_transport_config  # noqa: E501

        OperationId: put_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_transport_config(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutTransportConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_transport_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_transport_config_with_http_info(name, type, sequence_id, body, **kwargs)  # noqa: E501
            return data

    def put_transport_config_with_http_info(self, name, type, sequence_id, body, **kwargs):  # noqa: E501
        """put_transport_config  # noqa: E501

        OperationId: put_transport_config Configuration data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_transport_config_with_http_info(name, type, sequence_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Reference to the name list key (required)
        :param str type: Reference to the type list key (required)
        :param int sequence_id: references the list key (required)
        :param PutTransportConfig body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'type', 'sequence_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_transport_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put_transport_config`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_transport_config`")  # noqa: E501
        # verify the required parameter 'sequence_id' is set
        if ('sequence_id' not in params or
                params['sequence_id'] is None):
            raise ValueError("Missing the required parameter `sequence_id` when calling `put_transport_config`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_transport_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'sequence_id' in params:
            path_params['sequence_id'] = params['sequence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/openconfig-acl:acl/acl-sets/acl-set={name},{type}/acl-entries/acl-entry={sequence_id}/transport/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
